// Autogenerated by jnigen. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' show Object, String, bool, double, int;
import 'dart:core' as core$_;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `java.time.ZoneId`
///
/// A time-zone ID, such as {@code Europe/Paris}.
///
/// A {@code ZoneId} is used to identify the rules used to convert between
/// an Instant and a LocalDateTime.
/// There are two distinct types of ID:
/// <ul>
/// <li>Fixed offsets - a fully resolved offset from UTC/Greenwich, that uses
///  the same offset for all local date-times
/// <li>Geographical regions - an area where a specific set of rules for finding
///  the offset from UTC/Greenwich apply
/// </ul>
/// Most fixed offsets are represented by ZoneOffset.
/// Calling \#normalized() on any {@code ZoneId} will ensure that a
/// fixed offset ID will be represented as a {@code ZoneOffset}.
///
/// The actual rules, describing when and how the offset changes, are defined by ZoneRules.
/// This class is simply an ID used to obtain the underlying rules.
/// This approach is taken because rules are defined by governments and change
/// frequently, whereas the ID is stable.
///
/// The distinction has other effects. Serializing the {@code ZoneId} will only send
/// the ID, whereas serializing the rules sends the entire data set.
/// Similarly, a comparison of two IDs only examines the ID, whereas
/// a comparison of two rules examines the entire data set.
///
/// <h3>Time-zone IDs</h3>
/// The ID is unique within the system.
/// There are three types of ID.
///
/// The simplest type of ID is that from {@code ZoneOffset}.
/// This consists of 'Z' and IDs starting with '+' or '-'.
///
/// The next type of ID are offset-style IDs with some form of prefix,
/// such as 'GMT+2' or 'UTC+01:00'.
/// The recognised prefixes are 'UTC', 'GMT' and 'UT'.
/// The offset is the suffix and will be normalized during creation.
/// These IDs can be normalized to a {@code ZoneOffset} using {@code normalized()}.
///
/// The third type of ID are region-based IDs. A region-based ID must be of
/// two or more characters, and not start with 'UTC', 'GMT', 'UT' '+' or '-'.
/// Region-based IDs are defined by configuration, see ZoneRulesProvider.
/// The configuration focuses on providing the lookup from the ID to the
/// underlying {@code ZoneRules}.
///
/// Time-zone rules are defined by governments and change frequently.
/// There are a number of organizations, known here as groups, that monitor
/// time-zone changes and collate them.
/// The default group is the IANA Time Zone Database (TZDB).
/// Other organizations include IATA (the airline industry body) and Microsoft.
///
/// Each group defines its own format for the region ID it provides.
/// The TZDB group defines IDs such as 'Europe/London' or 'America/New_York'.
/// TZDB IDs take precedence over other groups.
///
/// It is strongly recommended that the group name is included in all IDs supplied by
/// groups other than TZDB to avoid conflicts. For example, IATA airline time-zone
/// region IDs are typically the same as the three letter airport code.
/// However, the airport of Utrecht has the code 'UTC', which is obviously a conflict.
/// The recommended format for region IDs from groups other than TZDB is 'group~region'.
/// Thus if IATA data were defined, Utrecht airport would be 'IATA~UTC'.
///
/// <h3>Serialization</h3>
/// This class can be serialized and stores the string zone ID in the external form.
/// The {@code ZoneOffset} subclass uses a dedicated format that only stores the
/// offset from UTC/Greenwich.
///
/// A {@code ZoneId} can be deserialized in a Java Runtime where the ID is unknown.
/// For example, if a server-side Java Runtime has been updated with a new zone ID, but
/// the client-side Java Runtime has not been updated. In this case, the {@code ZoneId}
/// object will exist, and can be queried using {@code getId}, {@code equals},
/// {@code hashCode}, {@code toString}, {@code getDisplayName} and {@code normalized}.
/// However, any call to {@code getRules} will fail with {@code ZoneRulesException}.
/// This approach is designed to allow a ZonedDateTime to be loaded and
/// queried, but not modified, on a Java Runtime with incomplete time-zone information.
///
///
/// This is a <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>
/// class; use of identity-sensitive operations (including reference equality
/// ({@code ==}), identity hash code, or synchronization) on instances of
/// {@code ZoneId} may have unpredictable results and should be avoided.
/// The {@code equals} method should be used for comparisons.
///@implSpec This abstract class has two implementations, both of which are immutable and thread-safe.
/// One implementation models region-based IDs, the other is {@code ZoneOffset} modelling
/// offset-based IDs. This difference is visible in serialization.
///@since 1.8
class ZoneId extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ZoneId> $type;

  @jni$_.internal
  ZoneId.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/ZoneId');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ZoneId$NullableType();
  static const type = $ZoneId$Type();
  static final _id_SHORT_IDS = _class.staticFieldId(
    r'SHORT_IDS',
    r'Ljava/util/Map;',
  );

  /// from: `static public final java.util.Map<java.lang.String,java.lang.String> SHORT_IDS`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// A map of zone overrides to enable the short time-zone names to be used.
  ///
  /// Use of short zone IDs has been deprecated in {@code java.util.TimeZone}.
  /// This map allows the IDs to continue to be used via the
  /// \#of(String, Map) factory method.
  ///
  /// This map contains a mapping of the IDs that is in line with TZDB 2005r and
  /// later, where 'EST', 'MST' and 'HST' map to IDs which do not include daylight
  /// savings.
  ///
  /// This maps as follows:
  /// <ul>
  /// <li>EST - -05:00</li>
  /// <li>HST - -10:00</li>
  /// <li>MST - -07:00</li>
  /// <li>ACT - Australia/Darwin</li>
  /// <li>AET - Australia/Sydney</li>
  /// <li>AGT - America/Argentina/Buenos_Aires</li>
  /// <li>ART - Africa/Cairo</li>
  /// <li>AST - America/Anchorage</li>
  /// <li>BET - America/Sao_Paulo</li>
  /// <li>BST - Asia/Dhaka</li>
  /// <li>CAT - Africa/Harare</li>
  /// <li>CNT - America/St_Johns</li>
  /// <li>CST - America/Chicago</li>
  /// <li>CTT - Asia/Shanghai</li>
  /// <li>EAT - Africa/Addis_Ababa</li>
  /// <li>ECT - Europe/Paris</li>
  /// <li>IET - America/Indiana/Indianapolis</li>
  /// <li>IST - Asia/Kolkata</li>
  /// <li>JST - Asia/Tokyo</li>
  /// <li>MIT - Pacific/Apia</li>
  /// <li>NET - Asia/Yerevan</li>
  /// <li>NST - Pacific/Auckland</li>
  /// <li>PLT - Asia/Karachi</li>
  /// <li>PNT - America/Phoenix</li>
  /// <li>PRT - America/Puerto_Rico</li>
  /// <li>PST - America/Los_Angeles</li>
  /// <li>SST - Pacific/Guadalcanal</li>
  /// <li>VST - Asia/Ho_Chi_Minh</li>
  /// </ul>
  /// The map is unmodifiable.
  static jni$_.JMap<jni$_.JString?, jni$_.JString?>? get SHORT_IDS =>
      _id_SHORT_IDS.get(
          _class,
          const jni$_.JMapNullableType<jni$_.JString?, jni$_.JString?>(
              jni$_.JStringNullableType(), jni$_.JStringNullableType()));

  static final _id_systemDefault = _class.staticMethodId(
    r'systemDefault',
    r'()Ljava/time/ZoneId;',
  );

  static final _systemDefault = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.time.ZoneId systemDefault()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the system default time-zone.
  ///
  /// This queries TimeZone\#getDefault() to find the default time-zone
  /// and converts it to a {@code ZoneId}. If the system default time-zone is changed,
  /// then the result of this method will also change.
  ///@return the zone ID, not null
  ///@throws DateTimeException if the converted zone ID has an invalid format
  ///@throws ZoneRulesException if the converted zone region ID cannot be found
  static ZoneId? systemDefault() {
    return _systemDefault(
            _class.reference.pointer, _id_systemDefault as jni$_.JMethodIDPtr)
        .object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_getAvailableZoneIds = _class.staticMethodId(
    r'getAvailableZoneIds',
    r'()Ljava/util/Set;',
  );

  static final _getAvailableZoneIds = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.util.Set<java.lang.String> getAvailableZoneIds()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the set of available zone IDs.
  ///
  /// This set includes the string form of all available region-based IDs.
  /// Offset-based zone IDs are not included in the returned set.
  /// The ID can be passed to \#of(String) to create a {@code ZoneId}.
  ///
  /// The set of zone IDs can increase over time, although in a typical application
  /// the set of IDs is fixed. Each call to this method is thread-safe.
  ///@return a modifiable copy of the set of zone IDs, not null
  static jni$_.JSet<jni$_.JString?>? getAvailableZoneIds() {
    return _getAvailableZoneIds(_class.reference.pointer,
            _id_getAvailableZoneIds as jni$_.JMethodIDPtr)
        .object<jni$_.JSet<jni$_.JString?>?>(
            const jni$_.JSetNullableType<jni$_.JString?>(
                jni$_.JStringNullableType()));
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/String;Ljava/util/Map;)Ljava/time/ZoneId;',
  );

  static final _of = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZoneId of(java.lang.String zoneId, java.util.Map<java.lang.String,java.lang.String> aliasMap)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneId} using its ID using a map
  /// of aliases to supplement the standard zone IDs.
  ///
  /// Many users of time-zones use short abbreviations, such as PST for
  /// 'Pacific Standard Time' and PDT for 'Pacific Daylight Time'.
  /// These abbreviations are not unique, and so cannot be used as IDs.
  /// This method allows a map of string to time-zone to be setup and reused
  /// within an application.
  ///@param zoneId the time-zone ID, not null
  ///@param aliasMap a map of alias zone IDs (typically abbreviations) to real zone IDs, not null
  ///@return the zone ID, not null
  ///@throws DateTimeException if the zone ID has an invalid format
  ///@throws ZoneRulesException if the zone ID is a region ID that cannot be found
  static ZoneId? of(
    jni$_.JString? zoneId,
    jni$_.JMap<jni$_.JString?, jni$_.JString?>? aliasMap,
  ) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    final _$aliasMap = aliasMap?.reference ?? jni$_.jNullReference;
    return _of(_class.reference.pointer, _id_of as jni$_.JMethodIDPtr,
            _$zoneId.pointer, _$aliasMap.pointer)
        .object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/String;)Ljava/time/ZoneId;',
  );

  static final _of$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZoneId of(java.lang.String zoneId)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneId} from an ID ensuring that the
  /// ID is valid and available for use.
  ///
  /// This method parses the ID producing a {@code ZoneId} or {@code ZoneOffset}.
  /// A {@code ZoneOffset} is returned if the ID is 'Z', or starts with '+' or '-'.
  /// The result will always be a valid ID for which ZoneRules can be obtained.
  ///
  /// Parsing matches the zone ID step by step as follows.
  /// <ul>
  /// <li>If the zone ID equals 'Z', the result is {@code ZoneOffset.UTC}.
  /// <li>If the zone ID consists of a single letter, the zone ID is invalid
  ///  and {@code DateTimeException} is thrown.
  /// <li>If the zone ID starts with '+' or '-', the ID is parsed as a
  ///  {@code ZoneOffset} using ZoneOffset\#of(String).
  /// <li>If the zone ID equals 'GMT', 'UTC' or 'UT' then the result is a {@code ZoneId}
  ///  with the same ID and rules equivalent to {@code ZoneOffset.UTC}.
  /// <li>If the zone ID starts with 'UTC+', 'UTC-', 'GMT+', 'GMT-', 'UT+' or 'UT-'
  ///  then the ID is a prefixed offset-based ID. The ID is split in two, with
  ///  a two or three letter prefix and a suffix starting with the sign.
  ///  The suffix is parsed as a ZoneOffset\#of(String) ZoneOffset.
  ///  The result will be a {@code ZoneId} with the specified UTC/GMT/UT prefix
  ///  and the normalized offset ID as per ZoneOffset\#getId().
  ///  The rules of the returned {@code ZoneId} will be equivalent to the
  ///  parsed {@code ZoneOffset}.
  /// <li>All other IDs are parsed as region-based zone IDs. Region IDs must
  ///  match the regular expression <code>[A-Za-z][A-Za-z0-9~/._+-]+</code>
  ///  otherwise a {@code DateTimeException} is thrown. If the zone ID is not
  ///  in the configured set of IDs, {@code ZoneRulesException} is thrown.
  ///  The detailed format of the region ID depends on the group supplying the data.
  ///  The default set of data is supplied by the IANA Time Zone Database (TZDB).
  ///  This has region IDs of the form '{area}/{city}', such as 'Europe/Paris' or 'America/New_York'.
  ///  This is compatible with most IDs from java.util.TimeZone.
  /// </ul>
  ///@param zoneId the time-zone ID, not null
  ///@return the zone ID, not null
  ///@throws DateTimeException if the zone ID has an invalid format
  ///@throws ZoneRulesException if the zone ID is a region ID that cannot be found
  static ZoneId? of$1(
    jni$_.JString? zoneId,
  ) {
    final _$zoneId = zoneId?.reference ?? jni$_.jNullReference;
    return _of$1(_class.reference.pointer, _id_of$1 as jni$_.JMethodIDPtr,
            _$zoneId.pointer)
        .object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_ofOffset = _class.staticMethodId(
    r'ofOffset',
    r'(Ljava/lang/String;Ljava/time/ZoneOffset;)Ljava/time/ZoneId;',
  );

  static final _ofOffset = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZoneId ofOffset(java.lang.String prefix, java.time.ZoneOffset offset)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneId} wrapping an offset.
  ///
  /// If the prefix is "GMT", "UTC", or "UT" a {@code ZoneId}
  /// with the prefix and the non-zero offset is returned.
  /// If the prefix is empty {@code ""} the {@code ZoneOffset} is returned.
  ///@param prefix the time-zone ID, not null
  ///@param offset the offset, not null
  ///@return the zone ID, not null
  ///@throws IllegalArgumentException if the prefix is not one of
  ///     "GMT", "UTC", or "UT", or ""
  static ZoneId? ofOffset(
    jni$_.JString? prefix,
    ZoneOffset? offset,
  ) {
    final _$prefix = prefix?.reference ?? jni$_.jNullReference;
    final _$offset = offset?.reference ?? jni$_.jNullReference;
    return _ofOffset(
            _class.reference.pointer,
            _id_ofOffset as jni$_.JMethodIDPtr,
            _$prefix.pointer,
            _$offset.pointer)
        .object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/ZoneId;',
  );

  static final _from = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZoneId from(java.time.temporal.TemporalAccessor temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneId} from a temporal object.
  ///
  /// This obtains a zone based on the specified temporal.
  /// A {@code TemporalAccessor} represents an arbitrary set of date and time information,
  /// which this factory converts to an instance of {@code ZoneId}.
  ///
  /// A {@code TemporalAccessor} represents some form of date and time information.
  /// This factory converts the arbitrary temporal object to an instance of {@code ZoneId}.
  ///
  /// The conversion will try to obtain the zone in a way that favours region-based
  /// zones over offset-based zones using TemporalQueries\#zone().
  ///
  /// This method matches the signature of the functional interface TemporalQuery
  /// allowing it to be used as a query via method reference, {@code ZoneId::from}.
  ///@param temporal the temporal object to convert, not null
  ///@return the zone ID, not null
  ///@throws DateTimeException if unable to convert to a {@code ZoneId}
  static ZoneId? from(
    jni$_.JObject? temporal,
  ) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _from(_class.reference.pointer, _id_from as jni$_.JMethodIDPtr,
            _$temporal.pointer)
        .object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the unique time-zone ID.
  ///
  /// This ID uniquely defines this object.
  /// The format of an offset based ID is defined by ZoneOffset\#getId().
  ///@return the time-zone unique ID, not null
  jni$_.JString? getId() {
    return _getId(reference.pointer, _id_getId as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getDisplayName = _class.instanceMethodId(
    r'getDisplayName',
    r'(Ljava/time/format/TextStyle;Ljava/util/Locale;)Ljava/lang/String;',
  );

  static final _getDisplayName = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String getDisplayName(java.time.format.TextStyle style, java.util.Locale locale)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the textual representation of the zone, such as 'British Time' or
  /// '+02:00'.
  ///
  /// This returns the textual name used to identify the time-zone ID,
  /// suitable for presentation to the user.
  /// The parameters control the style of the returned text and the locale.
  ///
  /// If no textual mapping is found then the \#getId() full ID is returned.
  ///@param style the length of the text required, not null
  ///@param locale the locale to use, not null
  ///@return the text value of the zone, not null
  jni$_.JString? getDisplayName(
    jni$_.JObject? style,
    jni$_.JObject? locale,
  ) {
    final _$style = style?.reference ?? jni$_.jNullReference;
    final _$locale = locale?.reference ?? jni$_.jNullReference;
    return _getDisplayName(
            reference.pointer,
            _id_getDisplayName as jni$_.JMethodIDPtr,
            _$style.pointer,
            _$locale.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getRules = _class.instanceMethodId(
    r'getRules',
    r'()Ljava/time/zone/ZoneRules;',
  );

  static final _getRules = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public abstract java.time.zone.ZoneRules getRules()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the time-zone rules for this ID allowing calculations to be performed.
  ///
  /// The rules provide the functionality associated with a time-zone,
  /// such as finding the offset for a given instant or local date-time.
  ///
  /// A time-zone can be invalid if it is deserialized in a Java Runtime which
  /// does not have the same rules loaded as the Java Runtime that stored it.
  /// In this case, calling this method will throw a {@code ZoneRulesException}.
  ///
  /// The rules are supplied by ZoneRulesProvider. An advanced provider may
  /// support dynamic updates to the rules without restarting the Java Runtime.
  /// If so, then the result of this method may change over time.
  /// Each individual call will be still remain thread-safe.
  ///
  /// ZoneOffset will always return a set of rules where the offset never changes.
  ///@return the rules, not null
  ///@throws ZoneRulesException if no rules are available for this ID
  jni$_.JObject? getRules() {
    return _getRules(reference.pointer, _id_getRules as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_normalized = _class.instanceMethodId(
    r'normalized',
    r'()Ljava/time/ZoneId;',
  );

  static final _normalized = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.ZoneId normalized()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Normalizes the time-zone ID, returning a {@code ZoneOffset} where possible.
  ///
  /// The returns a normalized {@code ZoneId} that can be used in place of this ID.
  /// The result will have {@code ZoneRules} equivalent to those returned by this object,
  /// however the ID returned by {@code getId()} may be different.
  ///
  /// The normalization checks if the rules of this {@code ZoneId} have a fixed offset.
  /// If they do, then the {@code ZoneOffset} equal to that offset is returned.
  /// Otherwise {@code this} is returned.
  ///@return the time-zone unique ID, not null
  ZoneId? normalized() {
    return _normalized(reference.pointer, _id_normalized as jni$_.JMethodIDPtr)
        .object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object obj)`
  ///
  /// Checks if this time-zone ID is equal to another time-zone ID.
  ///
  /// The comparison is based on the ID.
  ///@param obj the object to check, null returns false
  ///@return true if this is equal to the other time-zone ID
  bool equals(
    jni$_.JObject? obj,
  ) {
    final _$obj = obj?.reference ?? jni$_.jNullReference;
    return _equals(
            reference.pointer, _id_equals as jni$_.JMethodIDPtr, _$obj.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  ///
  /// A hash code for this time-zone ID.
  ///@return a suitable hash code
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Outputs this zone as a {@code String}, using the ID.
  ///@return a string representation of this time-zone ID, not null
  jni$_.JString? toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $ZoneId$NullableType extends jni$_.JObjType<ZoneId?> {
  @jni$_.internal
  const $ZoneId$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZoneId;';

  @jni$_.internal
  @core$_.override
  ZoneId? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : ZoneId.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneId?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZoneId$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoneId$NullableType) &&
        other is $ZoneId$NullableType;
  }
}

final class $ZoneId$Type extends jni$_.JObjType<ZoneId> {
  @jni$_.internal
  const $ZoneId$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZoneId;';

  @jni$_.internal
  @core$_.override
  ZoneId fromReference(jni$_.JReference reference) => ZoneId.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneId?> get nullableType => const $ZoneId$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZoneId$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoneId$Type) && other is $ZoneId$Type;
  }
}

/// from: `java.time.ZonedDateTime`
///
/// A date-time with a time-zone in the ISO-8601 calendar system,
/// such as {@code 2007-12-03T10:15:30+01:00 Europe/Paris}.
///
/// {@code ZonedDateTime} is an immutable representation of a date-time with a time-zone.
/// This class stores all date and time fields, to a precision of nanoseconds,
/// and a time-zone, with a zone offset used to handle ambiguous local date-times.
/// For example, the value
/// "2nd October 2007 at 13:45.30.123456789 +02:00 in the Europe/Paris time-zone"
/// can be stored in a {@code ZonedDateTime}.
///
/// This class handles conversion from the local time-line of {@code LocalDateTime}
/// to the instant time-line of {@code Instant}.
/// The difference between the two time-lines is the offset from UTC/Greenwich,
/// represented by a {@code ZoneOffset}.
///
/// Converting between the two time-lines involves calculating the offset using the
/// ZoneRules rules accessed from the {@code ZoneId}.
/// Obtaining the offset for an instant is simple, as there is exactly one valid
/// offset for each instant. By contrast, obtaining the offset for a local date-time
/// is not straightforward. There are three cases:
/// <ul>
/// <li>Normal, with one valid offset. For the vast majority of the year, the normal
///  case applies, where there is a single valid offset for the local date-time.</li>
/// <li>Gap, with zero valid offsets. This is when clocks jump forward typically
///  due to the spring daylight savings change from "winter" to "summer".
///  In a gap there are local date-time values with no valid offset.</li>
/// <li>Overlap, with two valid offsets. This is when clocks are set back typically
///  due to the autumn daylight savings change from "summer" to "winter".
///  In an overlap there are local date-time values with two valid offsets.</li>
/// </ul>
///
/// Any method that converts directly or implicitly from a local date-time to an
/// instant by obtaining the offset has the potential to be complicated.
///
/// For Gaps, the general strategy is that if the local date-time falls in the
/// middle of a Gap, then the resulting zoned date-time will have a local date-time
/// shifted forwards by the length of the Gap, resulting in a date-time in the later
/// offset, typically "summer" time.
///
/// For Overlaps, the general strategy is that if the local date-time falls in the
/// middle of an Overlap, then the previous offset will be retained. If there is no
/// previous offset, or the previous offset is invalid, then the earlier offset is
/// used, typically "summer" time.. Two additional methods,
/// \#withEarlierOffsetAtOverlap() and \#withLaterOffsetAtOverlap(),
/// help manage the case of an overlap.
///
/// In terms of design, this class should be viewed primarily as the combination
/// of a {@code LocalDateTime} and a {@code ZoneId}. The {@code ZoneOffset} is
/// a vital, but secondary, piece of information, used to ensure that the class
/// represents an instant, especially during a daylight savings overlap.
///
///
/// This is a <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>
/// class; use of identity-sensitive operations (including reference equality
/// ({@code ==}), identity hash code, or synchronization) on instances of
/// {@code ZonedDateTime} may have unpredictable results and should be avoided.
/// The {@code equals} method should be used for comparisons.
///@implSpec A {@code ZonedDateTime} holds state equivalent to three separate objects,
/// a {@code LocalDateTime}, a {@code ZoneId} and the resolved {@code ZoneOffset}.
/// The offset and local date-time are used to define an instant when necessary.
/// The zone ID is used to obtain the rules for how and when the offset changes.
/// The offset cannot be freely set, as the zone controls which offsets are valid.
///
/// This class is immutable and thread-safe.
///@since 1.8
class ZonedDateTime extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ZonedDateTime> $type;

  @jni$_.internal
  ZonedDateTime.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/ZonedDateTime');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ZonedDateTime$NullableType();
  static const type = $ZonedDateTime$Type();
  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _now = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.time.ZonedDateTime now()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains the current date-time from the system clock in the default time-zone.
  ///
  /// This will query the Clock\#systemDefaultZone() system clock in the default
  /// time-zone to obtain the current date-time.
  /// The zone and offset will be set based on the time-zone in the clock.
  ///
  /// Using this method will prevent the ability to use an alternate clock for testing
  /// because the clock is hard-coded.
  ///@return the current date-time using the system clock, not null
  static ZonedDateTime? now() {
    return _now(_class.reference.pointer, _id_now as jni$_.JMethodIDPtr)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _now$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime now(java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains the current date-time from the system clock in the specified time-zone.
  ///
  /// This will query the Clock\#system(ZoneId) system clock to obtain the current date-time.
  /// Specifying the time-zone avoids dependence on the default time-zone.
  /// The offset will be calculated from the specified time-zone.
  ///
  /// Using this method will prevent the ability to use an alternate clock for testing
  /// because the clock is hard-coded.
  ///@param zone the zone ID to use, not null
  ///@return the current date-time using the system clock, not null
  static ZonedDateTime? now$1(
    ZoneId? zone,
  ) {
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _now$1(_class.reference.pointer, _id_now$1 as jni$_.JMethodIDPtr,
            _$zone.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_now$2 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/ZonedDateTime;',
  );

  static final _now$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains the current date-time from the specified clock.
  ///
  /// This will query the specified clock to obtain the current date-time.
  /// The zone and offset will be set based on the time-zone in the clock.
  ///
  /// Using this method allows the use of an alternate clock for testing.
  /// The alternate clock may be introduced using Clock dependency injection.
  ///@param clock the clock to use, not null
  ///@return the current date-time, not null
  static ZonedDateTime? now$2(
    jni$_.JObject? clock,
  ) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$2(_class.reference.pointer, _id_now$2 as jni$_.JMethodIDPtr,
            _$clock.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_of = _class.staticMethodId(
    r'of',
    r'(Ljava/time/LocalDate;Ljava/time/LocalTime;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _of = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime of(java.time.LocalDate date, java.time.LocalTime time, java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} from a local date and time.
  ///
  /// This creates a zoned date-time matching the input local date and time as closely as possible.
  /// Time-zone rules, such as daylight savings, mean that not every local date-time
  /// is valid for the specified zone, thus the local date-time may be adjusted.
  ///
  /// The local date time and first combined to form a local date-time.
  /// The local date-time is then resolved to a single instant on the time-line.
  /// This is achieved by finding a valid offset from UTC/Greenwich for the local
  /// date-time as defined by the ZoneRules rules of the zone ID.
  ///
  /// In most cases, there is only one valid offset for a local date-time.
  /// In the case of an overlap, when clocks are set back, there are two valid offsets.
  /// This method uses the earlier offset typically corresponding to "summer".
  ///
  /// In the case of a gap, when clocks jump forward, there is no valid offset.
  /// Instead, the local date-time is adjusted to be later by the length of the gap.
  /// For a typical one hour daylight savings change, the local date-time will be
  /// moved one hour later into the offset typically corresponding to "summer".
  ///@param date the local date, not null
  ///@param time the local time, not null
  ///@param zone the time-zone, not null
  ///@return the offset date-time, not null
  static ZonedDateTime? of(
    jni$_.JObject? date,
    jni$_.JObject? time,
    ZoneId? zone,
  ) {
    final _$date = date?.reference ?? jni$_.jNullReference;
    final _$time = time?.reference ?? jni$_.jNullReference;
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _of(_class.reference.pointer, _id_of as jni$_.JMethodIDPtr,
            _$date.pointer, _$time.pointer, _$zone.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_of$1 = _class.staticMethodId(
    r'of',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _of$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime of(java.time.LocalDateTime localDateTime, java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} from a local date-time.
  ///
  /// This creates a zoned date-time matching the input local date-time as closely as possible.
  /// Time-zone rules, such as daylight savings, mean that not every local date-time
  /// is valid for the specified zone, thus the local date-time may be adjusted.
  ///
  /// The local date-time is resolved to a single instant on the time-line.
  /// This is achieved by finding a valid offset from UTC/Greenwich for the local
  /// date-time as defined by the ZoneRules rules of the zone ID.
  ///
  /// In most cases, there is only one valid offset for a local date-time.
  /// In the case of an overlap, when clocks are set back, there are two valid offsets.
  /// This method uses the earlier offset typically corresponding to "summer".
  ///
  /// In the case of a gap, when clocks jump forward, there is no valid offset.
  /// Instead, the local date-time is adjusted to be later by the length of the gap.
  /// For a typical one hour daylight savings change, the local date-time will be
  /// moved one hour later into the offset typically corresponding to "summer".
  ///@param localDateTime the local date-time, not null
  ///@param zone the time-zone, not null
  ///@return the zoned date-time, not null
  static ZonedDateTime? of$1(
    jni$_.JObject? localDateTime,
    ZoneId? zone,
  ) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _of$1(_class.reference.pointer, _id_of$1 as jni$_.JMethodIDPtr,
            _$localDateTime.pointer, _$zone.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_of$2 = _class.staticMethodId(
    r'of',
    r'(IIIIIIILjava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _of$2 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Int32,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              int,
              int,
              int,
              int,
              int,
              int,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanoOfSecond, java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} from a year, month, day,
  /// hour, minute, second, nanosecond and time-zone.
  ///
  /// This creates a zoned date-time matching the local date-time of the seven
  /// specified fields as closely as possible.
  /// Time-zone rules, such as daylight savings, mean that not every local date-time
  /// is valid for the specified zone, thus the local date-time may be adjusted.
  ///
  /// The local date-time is resolved to a single instant on the time-line.
  /// This is achieved by finding a valid offset from UTC/Greenwich for the local
  /// date-time as defined by the ZoneRules rules of the zone ID.
  ///
  /// In most cases, there is only one valid offset for a local date-time.
  /// In the case of an overlap, when clocks are set back, there are two valid offsets.
  /// This method uses the earlier offset typically corresponding to "summer".
  ///
  /// In the case of a gap, when clocks jump forward, there is no valid offset.
  /// Instead, the local date-time is adjusted to be later by the length of the gap.
  /// For a typical one hour daylight savings change, the local date-time will be
  /// moved one hour later into the offset typically corresponding to "summer".
  ///
  /// This method exists primarily for writing test cases.
  /// Non test-code will typically use other methods to create an offset time.
  /// {@code LocalDateTime} has five additional convenience variants of the
  /// equivalent factory method taking fewer arguments.
  /// They are not provided here to reduce the footprint of the API.
  ///@param year the year to represent, from MIN_YEAR to MAX_YEAR
  ///@param month the month-of-year to represent, from 1 (January) to 12 (December)
  ///@param dayOfMonth the day-of-month to represent, from 1 to 31
  ///@param hour the hour-of-day to represent, from 0 to 23
  ///@param minute the minute-of-hour to represent, from 0 to 59
  ///@param second the second-of-minute to represent, from 0 to 59
  ///@param nanoOfSecond the nano-of-second to represent, from 0 to 999,999,999
  ///@param zone the time-zone, not null
  ///@return the offset date-time, not null
  ///@throws DateTimeException if the value of any field is out of range, or
  ///  if the day-of-month is invalid for the month-year
  static ZonedDateTime? of$2(
    int year,
    int month,
    int dayOfMonth,
    int hour,
    int minute,
    int second,
    int nanoOfSecond,
    ZoneId? zone,
  ) {
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _of$2(
            _class.reference.pointer,
            _id_of$2 as jni$_.JMethodIDPtr,
            year,
            month,
            dayOfMonth,
            hour,
            minute,
            second,
            nanoOfSecond,
            _$zone.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofLocal = _class.staticMethodId(
    r'ofLocal',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneId;Ljava/time/ZoneOffset;)Ljava/time/ZonedDateTime;',
  );

  static final _ofLocal = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime ofLocal(java.time.LocalDateTime localDateTime, java.time.ZoneId zone, java.time.ZoneOffset preferredOffset)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} from a local date-time
  /// using the preferred offset if possible.
  ///
  /// The local date-time is resolved to a single instant on the time-line.
  /// This is achieved by finding a valid offset from UTC/Greenwich for the local
  /// date-time as defined by the ZoneRules rules of the zone ID.
  ///
  /// In most cases, there is only one valid offset for a local date-time.
  /// In the case of an overlap, where clocks are set back, there are two valid offsets.
  /// If the preferred offset is one of the valid offsets then it is used.
  /// Otherwise the earlier valid offset is used, typically corresponding to "summer".
  ///
  /// In the case of a gap, where clocks jump forward, there is no valid offset.
  /// Instead, the local date-time is adjusted to be later by the length of the gap.
  /// For a typical one hour daylight savings change, the local date-time will be
  /// moved one hour later into the offset typically corresponding to "summer".
  ///@param localDateTime the local date-time, not null
  ///@param zone the time-zone, not null
  ///@param preferredOffset the zone offset, null if no preference
  ///@return the zoned date-time, not null
  static ZonedDateTime? ofLocal(
    jni$_.JObject? localDateTime,
    ZoneId? zone,
    ZoneOffset? preferredOffset,
  ) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    final _$preferredOffset =
        preferredOffset?.reference ?? jni$_.jNullReference;
    return _ofLocal(_class.reference.pointer, _id_ofLocal as jni$_.JMethodIDPtr,
            _$localDateTime.pointer, _$zone.pointer, _$preferredOffset.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofInstant = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/Instant;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _ofInstant = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime ofInstant(java.time.Instant instant, java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} from an {@code Instant}.
  ///
  /// This creates a zoned date-time with the same instant as that specified.
  /// Calling \#toInstant() will return an instant equal to the one used here.
  ///
  /// Converting an instant to a zoned date-time is simple as there is only one valid
  /// offset for each instant.
  ///@param instant the instant to create the date-time from, not null
  ///@param zone the time-zone, not null
  ///@return the zoned date-time, not null
  ///@throws DateTimeException if the result exceeds the supported range
  static ZonedDateTime? ofInstant(
    Instant? instant,
    ZoneId? zone,
  ) {
    final _$instant = instant?.reference ?? jni$_.jNullReference;
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _ofInstant(
            _class.reference.pointer,
            _id_ofInstant as jni$_.JMethodIDPtr,
            _$instant.pointer,
            _$zone.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofInstant$1 = _class.staticMethodId(
    r'ofInstant',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneOffset;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _ofInstant$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime ofInstant(java.time.LocalDateTime localDateTime, java.time.ZoneOffset offset, java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} from the instant formed by combining
  /// the local date-time and offset.
  ///
  /// This creates a zoned date-time by LocalDateTime\#toInstant(ZoneOffset) combining
  /// the {@code LocalDateTime} and {@code ZoneOffset}.
  /// This combination uniquely specifies an instant without ambiguity.
  ///
  /// Converting an instant to a zoned date-time is simple as there is only one valid
  /// offset for each instant. If the valid offset is different to the offset specified,
  /// then the date-time and offset of the zoned date-time will differ from those specified.
  ///
  /// If the {@code ZoneId} to be used is a {@code ZoneOffset}, this method is equivalent
  /// to \#of(LocalDateTime, ZoneId).
  ///@param localDateTime the local date-time, not null
  ///@param offset the zone offset, not null
  ///@param zone the time-zone, not null
  ///@return the zoned date-time, not null
  static ZonedDateTime? ofInstant$1(
    jni$_.JObject? localDateTime,
    ZoneOffset? offset,
    ZoneId? zone,
  ) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$offset = offset?.reference ?? jni$_.jNullReference;
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _ofInstant$1(
            _class.reference.pointer,
            _id_ofInstant$1 as jni$_.JMethodIDPtr,
            _$localDateTime.pointer,
            _$offset.pointer,
            _$zone.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_ofStrict = _class.staticMethodId(
    r'ofStrict',
    r'(Ljava/time/LocalDateTime;Ljava/time/ZoneOffset;Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _ofStrict = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime ofStrict(java.time.LocalDateTime localDateTime, java.time.ZoneOffset offset, java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} strictly validating the
  /// combination of local date-time, offset and zone ID.
  ///
  /// This creates a zoned date-time ensuring that the offset is valid for the
  /// local date-time according to the rules of the specified zone.
  /// If the offset is invalid, an exception is thrown.
  ///@param localDateTime the local date-time, not null
  ///@param offset the zone offset, not null
  ///@param zone the time-zone, not null
  ///@return the zoned date-time, not null
  ///@throws DateTimeException if the combination of arguments is invalid
  static ZonedDateTime? ofStrict(
    jni$_.JObject? localDateTime,
    ZoneOffset? offset,
    ZoneId? zone,
  ) {
    final _$localDateTime = localDateTime?.reference ?? jni$_.jNullReference;
    final _$offset = offset?.reference ?? jni$_.jNullReference;
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _ofStrict(
            _class.reference.pointer,
            _id_ofStrict as jni$_.JMethodIDPtr,
            _$localDateTime.pointer,
            _$offset.pointer,
            _$zone.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/ZonedDateTime;',
  );

  static final _from = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime from(java.time.temporal.TemporalAccessor temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} from a temporal object.
  ///
  /// This obtains a zoned date-time based on the specified temporal.
  /// A {@code TemporalAccessor} represents an arbitrary set of date and time information,
  /// which this factory converts to an instance of {@code ZonedDateTime}.
  ///
  /// The conversion will first obtain a {@code ZoneId} from the temporal object,
  /// falling back to a {@code ZoneOffset} if necessary. It will then try to obtain
  /// an {@code Instant}, falling back to a {@code LocalDateTime} if necessary.
  /// The result will be either the combination of {@code ZoneId} or {@code ZoneOffset}
  /// with {@code Instant} or {@code LocalDateTime}.
  /// Implementations are permitted to perform optimizations such as accessing
  /// those fields that are equivalent to the relevant objects.
  ///
  /// This method matches the signature of the functional interface TemporalQuery
  /// allowing it to be used as a query via method reference, {@code ZonedDateTime::from}.
  ///@param temporal the temporal object to convert, not null
  ///@return the zoned date-time, not null
  ///@throws DateTimeException if unable to convert to an {@code ZonedDateTime}
  static ZonedDateTime? from(
    jni$_.JObject? temporal,
  ) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _from(_class.reference.pointer, _id_from as jni$_.JMethodIDPtr,
            _$temporal.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/ZonedDateTime;',
  );

  static final _parse = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime parse(java.lang.CharSequence text)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} from a text string such as
  /// {@code 2007-12-03T10:15:30+01:00[Europe/Paris]}.
  ///
  /// The string must represent a valid date-time and is parsed using
  /// java.time.format.DateTimeFormatter\#ISO_ZONED_DATE_TIME.
  ///@param text the text to parse such as "2007-12-03T10:15:30+01:00[Europe/Paris]", not null
  ///@return the parsed zoned date-time, not null
  ///@throws DateTimeParseException if the text cannot be parsed
  static ZonedDateTime? parse(
    jni$_.JObject? text,
  ) {
    final _$text = text?.reference ?? jni$_.jNullReference;
    return _parse(_class.reference.pointer, _id_parse as jni$_.JMethodIDPtr,
            _$text.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;Ljava/time/format/DateTimeFormatter;)Ljava/time/ZonedDateTime;',
  );

  static final _parse$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZonedDateTime parse(java.lang.CharSequence text, java.time.format.DateTimeFormatter formatter)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZonedDateTime} from a text string using a specific formatter.
  ///
  /// The text is parsed using the formatter, returning a date-time.
  ///@param text the text to parse, not null
  ///@param formatter the formatter to use, not null
  ///@return the parsed zoned date-time, not null
  ///@throws DateTimeParseException if the text cannot be parsed
  static ZonedDateTime? parse$1(
    jni$_.JObject? text,
    jni$_.JObject? formatter,
  ) {
    final _$text = text?.reference ?? jni$_.jNullReference;
    final _$formatter = formatter?.reference ?? jni$_.jNullReference;
    return _parse$1(_class.reference.pointer, _id_parse$1 as jni$_.JMethodIDPtr,
            _$text.pointer, _$formatter.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField field)`
  ///
  /// Checks if the specified field is supported.
  ///
  /// This checks if this date-time can be queried for the specified field.
  /// If false, then calling the \#range(TemporalField) range,
  /// \#get(TemporalField) get and \#with(TemporalField, long)
  /// methods will throw an exception.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The supported fields are:
  /// <ul>
  /// <li>{@code NANO_OF_SECOND}
  /// <li>{@code NANO_OF_DAY}
  /// <li>{@code MICRO_OF_SECOND}
  /// <li>{@code MICRO_OF_DAY}
  /// <li>{@code MILLI_OF_SECOND}
  /// <li>{@code MILLI_OF_DAY}
  /// <li>{@code SECOND_OF_MINUTE}
  /// <li>{@code SECOND_OF_DAY}
  /// <li>{@code MINUTE_OF_HOUR}
  /// <li>{@code MINUTE_OF_DAY}
  /// <li>{@code HOUR_OF_AMPM}
  /// <li>{@code CLOCK_HOUR_OF_AMPM}
  /// <li>{@code HOUR_OF_DAY}
  /// <li>{@code CLOCK_HOUR_OF_DAY}
  /// <li>{@code AMPM_OF_DAY}
  /// <li>{@code DAY_OF_WEEK}
  /// <li>{@code ALIGNED_DAY_OF_WEEK_IN_MONTH}
  /// <li>{@code ALIGNED_DAY_OF_WEEK_IN_YEAR}
  /// <li>{@code DAY_OF_MONTH}
  /// <li>{@code DAY_OF_YEAR}
  /// <li>{@code EPOCH_DAY}
  /// <li>{@code ALIGNED_WEEK_OF_MONTH}
  /// <li>{@code ALIGNED_WEEK_OF_YEAR}
  /// <li>{@code MONTH_OF_YEAR}
  /// <li>{@code PROLEPTIC_MONTH}
  /// <li>{@code YEAR_OF_ERA}
  /// <li>{@code YEAR}
  /// <li>{@code ERA}
  /// <li>{@code INSTANT_SECONDS}
  /// <li>{@code OFFSET_SECONDS}
  /// </ul>
  /// All other {@code ChronoField} instances will return false.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}
  /// passing {@code this} as the argument.
  /// Whether the field is supported is determined by the field.
  ///@param field the field to check, null returns false
  ///@return true if the field is supported on this date-time, false if not
  bool isSupported(
    jni$_.JObject? field,
  ) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _isSupported(reference.pointer,
            _id_isSupported as jni$_.JMethodIDPtr, _$field.pointer)
        .boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit unit)`
  ///
  /// Checks if the specified unit is supported.
  ///
  /// This checks if the specified unit can be added to, or subtracted from, this date-time.
  /// If false, then calling the \#plus(long, TemporalUnit) and
  /// \#minus(long, TemporalUnit) minus methods will throw an exception.
  ///
  /// If the unit is a ChronoUnit then the query is implemented here.
  /// The supported units are:
  /// <ul>
  /// <li>{@code NANOS}
  /// <li>{@code MICROS}
  /// <li>{@code MILLIS}
  /// <li>{@code SECONDS}
  /// <li>{@code MINUTES}
  /// <li>{@code HOURS}
  /// <li>{@code HALF_DAYS}
  /// <li>{@code DAYS}
  /// <li>{@code WEEKS}
  /// <li>{@code MONTHS}
  /// <li>{@code YEARS}
  /// <li>{@code DECADES}
  /// <li>{@code CENTURIES}
  /// <li>{@code MILLENNIA}
  /// <li>{@code ERAS}
  /// </ul>
  /// All other {@code ChronoUnit} instances will return false.
  ///
  /// If the unit is not a {@code ChronoUnit}, then the result of this method
  /// is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}
  /// passing {@code this} as the argument.
  /// Whether the unit is supported is determined by the unit.
  ///@param unit the unit to check, null returns false
  ///@return true if the unit can be added/subtracted, false if not
  bool isSupported$1(
    jni$_.JObject? unit,
  ) {
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(reference.pointer,
            _id_isSupported$1 as jni$_.JMethodIDPtr, _$unit.pointer)
        .boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField field)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the range of valid values for the specified field.
  ///
  /// The range object expresses the minimum and maximum valid values for a field.
  /// This date-time is used to enhance the accuracy of the returned range.
  /// If it is not possible to return the range, because the field is not supported
  /// or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The \#isSupported(TemporalField) supported fields will return
  /// appropriate range instances.
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}
  /// passing {@code this} as the argument.
  /// Whether the range can be obtained is determined by the field.
  ///@param field the field to query the range for, not null
  ///@return the range of valid values for the field, not null
  ///@throws DateTimeException if the range for the field cannot be obtained
  ///@throws UnsupportedTemporalTypeException if the field is not supported
  jni$_.JObject? range(
    jni$_.JObject? field,
  ) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _range(
            reference.pointer, _id_range as jni$_.JMethodIDPtr, _$field.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int get(java.time.temporal.TemporalField field)`
  ///
  /// Gets the value of the specified field from this date-time as an {@code int}.
  ///
  /// This queries this date-time for the value of the specified field.
  /// The returned value will always be within the valid range of values for the field.
  /// If it is not possible to return the value, because the field is not supported
  /// or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The \#isSupported(TemporalField) supported fields will return valid
  /// values based on this date-time, except {@code NANO_OF_DAY}, {@code MICRO_OF_DAY},
  /// {@code EPOCH_DAY}, {@code PROLEPTIC_MONTH} and {@code INSTANT_SECONDS} which are too
  /// large to fit in an {@code int} and throw an {@code UnsupportedTemporalTypeException}.
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
  /// passing {@code this} as the argument. Whether the value can be obtained,
  /// and what the value represents, is determined by the field.
  ///@param field the field to get, not null
  ///@return the value for the field
  ///@throws DateTimeException if a value for the field cannot be obtained or
  ///         the value is outside the range of valid values for the field
  ///@throws UnsupportedTemporalTypeException if the field is not supported or
  ///         the range of values exceeds an {@code int}
  ///@throws ArithmeticException if numeric overflow occurs
  int get(
    jni$_.JObject? field,
  ) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _get(
            reference.pointer, _id_get as jni$_.JMethodIDPtr, _$field.pointer)
        .integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public long getLong(java.time.temporal.TemporalField field)`
  ///
  /// Gets the value of the specified field from this date-time as a {@code long}.
  ///
  /// This queries this date-time for the value of the specified field.
  /// If it is not possible to return the value, because the field is not supported
  /// or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The \#isSupported(TemporalField) supported fields will return valid
  /// values based on this date-time.
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
  /// passing {@code this} as the argument. Whether the value can be obtained,
  /// and what the value represents, is determined by the field.
  ///@param field the field to get, not null
  ///@return the value for the field
  ///@throws DateTimeException if a value for the field cannot be obtained
  ///@throws UnsupportedTemporalTypeException if the field is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  int getLong(
    jni$_.JObject? field,
  ) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _getLong(reference.pointer, _id_getLong as jni$_.JMethodIDPtr,
            _$field.pointer)
        .long;
  }

  static final _id_getOffset = _class.instanceMethodId(
    r'getOffset',
    r'()Ljava/time/ZoneOffset;',
  );

  static final _getOffset = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.ZoneOffset getOffset()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the zone offset, such as '+01:00'.
  ///
  /// This is the offset of the local date-time from UTC/Greenwich.
  ///@return the zone offset, not null
  ZoneOffset? getOffset() {
    return _getOffset(reference.pointer, _id_getOffset as jni$_.JMethodIDPtr)
        .object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_withEarlierOffsetAtOverlap = _class.instanceMethodId(
    r'withEarlierOffsetAtOverlap',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _withEarlierOffsetAtOverlap =
      jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.JMethodIDPtr,
                  )>>('globalEnv_CallObjectMethod')
          .asFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>();

  /// from: `public java.time.ZonedDateTime withEarlierOffsetAtOverlap()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time changing the zone offset to the
  /// earlier of the two valid offsets at a local time-line overlap.
  ///
  /// This method only has any effect when the local time-line overlaps, such as
  /// at an autumn daylight savings cutover. In this scenario, there are two
  /// valid offsets for the local date-time. Calling this method will return
  /// a zoned date-time with the earlier of the two selected.
  ///
  /// If this method is called when it is not an overlap, {@code this}
  /// is returned.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@return a {@code ZonedDateTime} based on this date-time with the earlier offset, not null
  ZonedDateTime? withEarlierOffsetAtOverlap() {
    return _withEarlierOffsetAtOverlap(reference.pointer,
            _id_withEarlierOffsetAtOverlap as jni$_.JMethodIDPtr)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withLaterOffsetAtOverlap = _class.instanceMethodId(
    r'withLaterOffsetAtOverlap',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _withLaterOffsetAtOverlap = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.ZonedDateTime withLaterOffsetAtOverlap()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time changing the zone offset to the
  /// later of the two valid offsets at a local time-line overlap.
  ///
  /// This method only has any effect when the local time-line overlaps, such as
  /// at an autumn daylight savings cutover. In this scenario, there are two
  /// valid offsets for the local date-time. Calling this method will return
  /// a zoned date-time with the later of the two selected.
  ///
  /// If this method is called when it is not an overlap, {@code this}
  /// is returned.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@return a {@code ZonedDateTime} based on this date-time with the later offset, not null
  ZonedDateTime? withLaterOffsetAtOverlap() {
    return _withLaterOffsetAtOverlap(reference.pointer,
            _id_withLaterOffsetAtOverlap as jni$_.JMethodIDPtr)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_getZone = _class.instanceMethodId(
    r'getZone',
    r'()Ljava/time/ZoneId;',
  );

  static final _getZone = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.ZoneId getZone()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the time-zone, such as 'Europe/Paris'.
  ///
  /// This returns the zone ID. This identifies the time-zone ZoneRules rules
  /// that determine when and how the offset from UTC/Greenwich changes.
  ///
  /// The zone ID may be same as the {@linkplain \#getOffset() offset}.
  /// If this is true, then any future calculations, such as addition or subtraction,
  /// have no complex edge cases due to time-zone rules.
  /// See also \#withFixedOffsetZone().
  ///@return the time-zone, not null
  ZoneId? getZone() {
    return _getZone(reference.pointer, _id_getZone as jni$_.JMethodIDPtr)
        .object<ZoneId?>(const $ZoneId$NullableType());
  }

  static final _id_withZoneSameLocal = _class.instanceMethodId(
    r'withZoneSameLocal',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _withZoneSameLocal = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.ZonedDateTime withZoneSameLocal(java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time with a different time-zone,
  /// retaining the local date-time if possible.
  ///
  /// This method changes the time-zone and retains the local date-time.
  /// The local date-time is only changed if it is invalid for the new zone,
  /// determined using the same approach as
  /// \#ofLocal(LocalDateTime, ZoneId, ZoneOffset).
  ///
  /// To change the zone and adjust the local date-time,
  /// use \#withZoneSameInstant(ZoneId).
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param zone the time-zone to change to, not null
  ///@return a {@code ZonedDateTime} based on this date-time with the requested zone, not null
  ZonedDateTime? withZoneSameLocal(
    ZoneId? zone,
  ) {
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _withZoneSameLocal(reference.pointer,
            _id_withZoneSameLocal as jni$_.JMethodIDPtr, _$zone.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withZoneSameInstant = _class.instanceMethodId(
    r'withZoneSameInstant',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _withZoneSameInstant = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.ZonedDateTime withZoneSameInstant(java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time with a different time-zone,
  /// retaining the instant.
  ///
  /// This method changes the time-zone and retains the instant.
  /// This normally results in a change to the local date-time.
  ///
  /// This method is based on retaining the same instant, thus gaps and overlaps
  /// in the local time-line have no effect on the result.
  ///
  /// To change the offset while keeping the local time,
  /// use \#withZoneSameLocal(ZoneId).
  ///@param zone the time-zone to change to, not null
  ///@return a {@code ZonedDateTime} based on this date-time with the requested zone, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? withZoneSameInstant(
    ZoneId? zone,
  ) {
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _withZoneSameInstant(reference.pointer,
            _id_withZoneSameInstant as jni$_.JMethodIDPtr, _$zone.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withFixedOffsetZone = _class.instanceMethodId(
    r'withFixedOffsetZone',
    r'()Ljava/time/ZonedDateTime;',
  );

  static final _withFixedOffsetZone = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.ZonedDateTime withFixedOffsetZone()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time with the zone ID set to the offset.
  ///
  /// This returns a zoned date-time where the zone ID is the same as \#getOffset().
  /// The local date-time, offset and instant of the result will be the same as in this date-time.
  ///
  /// Setting the date-time to a fixed single offset means that any future
  /// calculations, such as addition or subtraction, have no complex edge cases
  /// due to time-zone rules.
  /// This might also be useful when sending a zoned date-time across a network,
  /// as most protocols, such as ISO-8601, only handle offsets,
  /// and not region-based zone IDs.
  ///
  /// This is equivalent to {@code ZonedDateTime.of(zdt.toLocalDateTime(), zdt.getOffset())}.
  ///@return a {@code ZonedDateTime} with the zone ID set to the offset, not null
  ZonedDateTime? withFixedOffsetZone() {
    return _withFixedOffsetZone(
            reference.pointer, _id_withFixedOffsetZone as jni$_.JMethodIDPtr)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_toLocalDateTime = _class.instanceMethodId(
    r'toLocalDateTime',
    r'()Ljava/time/LocalDateTime;',
  );

  static final _toLocalDateTime = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.LocalDateTime toLocalDateTime()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the {@code LocalDateTime} part of this date-time.
  ///
  /// This returns a {@code LocalDateTime} with the same year, month, day and time
  /// as this date-time.
  ///@return the local date-time part of this date-time, not null
  jni$_.JObject? toLocalDateTime() {
    return _toLocalDateTime(
            reference.pointer, _id_toLocalDateTime as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toLocalDate = _class.instanceMethodId(
    r'toLocalDate',
    r'()Ljava/time/LocalDate;',
  );

  static final _toLocalDate = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.LocalDate toLocalDate()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the {@code LocalDate} part of this date-time.
  ///
  /// This returns a {@code LocalDate} with the same year, month and day
  /// as this date-time.
  ///@return the date part of this date-time, not null
  jni$_.JObject? toLocalDate() {
    return _toLocalDate(
            reference.pointer, _id_toLocalDate as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getYear = _class.instanceMethodId(
    r'getYear',
    r'()I',
  );

  static final _getYear = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getYear()`
  ///
  /// Gets the year field.
  ///
  /// This method returns the primitive {@code int} value for the year.
  ///
  /// The year returned by this method is proleptic as per {@code get(YEAR)}.
  /// To obtain the year-of-era, use {@code get(YEAR_OF_ERA)}.
  ///@return the year, from MIN_YEAR to MAX_YEAR
  int getYear() {
    return _getYear(reference.pointer, _id_getYear as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getMonthValue = _class.instanceMethodId(
    r'getMonthValue',
    r'()I',
  );

  static final _getMonthValue = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getMonthValue()`
  ///
  /// Gets the month-of-year field from 1 to 12.
  ///
  /// This method returns the month as an {@code int} from 1 to 12.
  /// Application code is frequently clearer if the enum Month
  /// is used by calling \#getMonth().
  ///@return the month-of-year, from 1 to 12
  ///@see \#getMonth()
  int getMonthValue() {
    return _getMonthValue(
            reference.pointer, _id_getMonthValue as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getMonth = _class.instanceMethodId(
    r'getMonth',
    r'()Ljava/time/Month;',
  );

  static final _getMonth = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.Month getMonth()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the month-of-year field using the {@code Month} enum.
  ///
  /// This method returns the enum Month for the month.
  /// This avoids confusion as to what {@code int} values mean.
  /// If you need access to the primitive {@code int} value then the enum
  /// provides the Month\#getValue() int value.
  ///@return the month-of-year, not null
  ///@see \#getMonthValue()
  jni$_.JObject? getMonth() {
    return _getMonth(reference.pointer, _id_getMonth as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getDayOfMonth = _class.instanceMethodId(
    r'getDayOfMonth',
    r'()I',
  );

  static final _getDayOfMonth = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getDayOfMonth()`
  ///
  /// Gets the day-of-month field.
  ///
  /// This method returns the primitive {@code int} value for the day-of-month.
  ///@return the day-of-month, from 1 to 31
  int getDayOfMonth() {
    return _getDayOfMonth(
            reference.pointer, _id_getDayOfMonth as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getDayOfYear = _class.instanceMethodId(
    r'getDayOfYear',
    r'()I',
  );

  static final _getDayOfYear = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getDayOfYear()`
  ///
  /// Gets the day-of-year field.
  ///
  /// This method returns the primitive {@code int} value for the day-of-year.
  ///@return the day-of-year, from 1 to 365, or 366 in a leap year
  int getDayOfYear() {
    return _getDayOfYear(
            reference.pointer, _id_getDayOfYear as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getDayOfWeek = _class.instanceMethodId(
    r'getDayOfWeek',
    r'()Ljava/time/DayOfWeek;',
  );

  static final _getDayOfWeek = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.DayOfWeek getDayOfWeek()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the day-of-week field, which is an enum {@code DayOfWeek}.
  ///
  /// This method returns the enum DayOfWeek for the day-of-week.
  /// This avoids confusion as to what {@code int} values mean.
  /// If you need access to the primitive {@code int} value then the enum
  /// provides the DayOfWeek\#getValue() int value.
  ///
  /// Additional information can be obtained from the {@code DayOfWeek}.
  /// This includes textual names of the values.
  ///@return the day-of-week, not null
  jni$_.JObject? getDayOfWeek() {
    return _getDayOfWeek(
            reference.pointer, _id_getDayOfWeek as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_toLocalTime = _class.instanceMethodId(
    r'toLocalTime',
    r'()Ljava/time/LocalTime;',
  );

  static final _toLocalTime = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.LocalTime toLocalTime()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the {@code LocalTime} part of this date-time.
  ///
  /// This returns a {@code LocalTime} with the same hour, minute, second and
  /// nanosecond as this date-time.
  ///@return the time part of this date-time, not null
  jni$_.JObject? toLocalTime() {
    return _toLocalTime(
            reference.pointer, _id_toLocalTime as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_getHour = _class.instanceMethodId(
    r'getHour',
    r'()I',
  );

  static final _getHour = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getHour()`
  ///
  /// Gets the hour-of-day field.
  ///@return the hour-of-day, from 0 to 23
  int getHour() {
    return _getHour(reference.pointer, _id_getHour as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getMinute = _class.instanceMethodId(
    r'getMinute',
    r'()I',
  );

  static final _getMinute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getMinute()`
  ///
  /// Gets the minute-of-hour field.
  ///@return the minute-of-hour, from 0 to 59
  int getMinute() {
    return _getMinute(reference.pointer, _id_getMinute as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getSecond = _class.instanceMethodId(
    r'getSecond',
    r'()I',
  );

  static final _getSecond = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getSecond()`
  ///
  /// Gets the second-of-minute field.
  ///@return the second-of-minute, from 0 to 59
  int getSecond() {
    return _getSecond(reference.pointer, _id_getSecond as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getNano = _class.instanceMethodId(
    r'getNano',
    r'()I',
  );

  static final _getNano = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getNano()`
  ///
  /// Gets the nano-of-second field.
  ///@return the nano-of-second, from 0 to 999,999,999
  int getNano() {
    return _getNano(reference.pointer, _id_getNano as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/ZonedDateTime;',
  );

  static final _with$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.ZonedDateTime with(java.time.temporal.TemporalAdjuster adjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns an adjusted copy of this date-time.
  ///
  /// This returns a {@code ZonedDateTime}, based on this one, with the date-time adjusted.
  /// The adjustment takes place using the specified adjuster strategy object.
  /// Read the documentation of the adjuster to understand what adjustment will be made.
  ///
  /// A simple adjuster might simply set the one of the fields, such as the year field.
  /// A more complex adjuster might set the date to the last day of the month.
  /// A selection of common adjustments is provided in
  /// java.time.temporal.TemporalAdjusters TemporalAdjusters.
  /// These include finding the "last day of the month" and "next Wednesday".
  /// Key date-time classes also implement the {@code TemporalAdjuster} interface,
  /// such as Month and java.time.MonthDay MonthDay.
  /// The adjuster is responsible for handling special cases, such as the varying
  /// lengths of month and leap years.
  ///
  /// For example this code returns a date on the last day of July:
  /// <pre>
  ///  import static java.time.Month.*;
  ///  import static java.time.temporal.TemporalAdjusters.*;
  ///
  ///  result = zonedDateTime.with(JULY).with(lastDayOfMonth());
  /// </pre>
  ///
  /// The classes LocalDate and LocalTime implement {@code TemporalAdjuster},
  /// thus this method can be used to change the date, time or offset:
  /// <pre>
  ///  result = zonedDateTime.with(date);
  ///  result = zonedDateTime.with(time);
  /// </pre>
  ///
  /// ZoneOffset also implements {@code TemporalAdjuster} however using it
  /// as an argument typically has no effect. The offset of a {@code ZonedDateTime} is
  /// controlled primarily by the time-zone. As such, changing the offset does not generally
  /// make sense, because there is only one valid offset for the local date-time and zone.
  /// If the zoned date-time is in a daylight savings overlap, then the offset is used
  /// to switch between the two valid offsets. In all other cases, the offset is ignored.
  ///
  /// The result of this method is obtained by invoking the
  /// TemporalAdjuster\#adjustInto(Temporal) method on the
  /// specified adjuster passing {@code this} as the argument.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param adjuster the adjuster to use, not null
  ///@return a {@code ZonedDateTime} based on {@code this} with the adjustment made, not null
  ///@throws DateTimeException if the adjustment cannot be made
  ///@throws ArithmeticException if numeric overflow occurs
  ZonedDateTime? with$(
    jni$_.JObject? adjuster,
  ) {
    final _$adjuster = adjuster?.reference ?? jni$_.jNullReference;
    return _with$(reference.pointer, _id_with$ as jni$_.JMethodIDPtr,
            _$adjuster.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/ZonedDateTime;',
  );

  static final _with$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public java.time.ZonedDateTime with(java.time.temporal.TemporalField field, long newValue)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time with the specified field set to a new value.
  ///
  /// This returns a {@code ZonedDateTime}, based on this one, with the value
  /// for the specified field changed.
  /// This can be used to change any supported field, such as the year, month or day-of-month.
  /// If it is not possible to set the value, because the field is not supported or for
  /// some other reason, an exception is thrown.
  ///
  /// In some cases, changing the specified field can cause the resulting date-time to become invalid,
  /// such as changing the month from 31st January to February would make the day-of-month invalid.
  /// In cases like this, the field is responsible for resolving the date. Typically it will choose
  /// the previous valid date, which would be the last valid day of February in this example.
  ///
  /// If the field is a ChronoField then the adjustment is implemented here.
  ///
  /// The {@code INSTANT_SECONDS} field will return a date-time with the specified instant.
  /// The zone and nano-of-second are unchanged.
  /// The result will have an offset derived from the new instant and original zone.
  /// If the new instant value is outside the valid range then a {@code DateTimeException} will be thrown.
  ///
  /// The {@code OFFSET_SECONDS} field will typically be ignored.
  /// The offset of a {@code ZonedDateTime} is controlled primarily by the time-zone.
  /// As such, changing the offset does not generally make sense, because there is only
  /// one valid offset for the local date-time and zone.
  /// If the zoned date-time is in a daylight savings overlap, then the offset is used
  /// to switch between the two valid offsets. In all other cases, the offset is ignored.
  /// If the new offset value is outside the valid range then a {@code DateTimeException} will be thrown.
  ///
  /// The other \#isSupported(TemporalField) supported fields will behave as per
  /// the matching method on LocalDateTime\#with(TemporalField, long) LocalDateTime.
  /// The zone is not part of the calculation and will be unchanged.
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}
  /// passing {@code this} as the argument. In this case, the field determines
  /// whether and how to adjust the instant.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param field the field to set in the result, not null
  ///@param newValue the new value of the field in the result
  ///@return a {@code ZonedDateTime} based on {@code this} with the specified field set, not null
  ///@throws DateTimeException if the field cannot be set
  ///@throws UnsupportedTemporalTypeException if the field is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  ZonedDateTime? with$1(
    jni$_.JObject? field,
    int newValue,
  ) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _with$1(reference.pointer, _id_with$1 as jni$_.JMethodIDPtr,
            _$field.pointer, newValue)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withYear = _class.instanceMethodId(
    r'withYear',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withYear = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withYear(int year)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the year altered.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#withYear(int) changing the year of the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param year the year to set in the result, from MIN_YEAR to MAX_YEAR
  ///@return a {@code ZonedDateTime} based on this date-time with the requested year, not null
  ///@throws DateTimeException if the year value is invalid
  ZonedDateTime? withYear(
    int year,
  ) {
    return _withYear(
            reference.pointer, _id_withYear as jni$_.JMethodIDPtr, year)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withMonth = _class.instanceMethodId(
    r'withMonth',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withMonth = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withMonth(int month)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the month-of-year altered.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#withMonth(int) changing the month of the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param month the month-of-year to set in the result, from 1 (January) to 12 (December)
  ///@return a {@code ZonedDateTime} based on this date-time with the requested month, not null
  ///@throws DateTimeException if the month-of-year value is invalid
  ZonedDateTime? withMonth(
    int month,
  ) {
    return _withMonth(
            reference.pointer, _id_withMonth as jni$_.JMethodIDPtr, month)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withDayOfMonth = _class.instanceMethodId(
    r'withDayOfMonth',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withDayOfMonth = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withDayOfMonth(int dayOfMonth)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the day-of-month altered.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#withDayOfMonth(int) changing the day-of-month of the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param dayOfMonth the day-of-month to set in the result, from 1 to 28-31
  ///@return a {@code ZonedDateTime} based on this date-time with the requested day, not null
  ///@throws DateTimeException if the day-of-month value is invalid,
  ///  or if the day-of-month is invalid for the month-year
  ZonedDateTime? withDayOfMonth(
    int dayOfMonth,
  ) {
    return _withDayOfMonth(reference.pointer,
            _id_withDayOfMonth as jni$_.JMethodIDPtr, dayOfMonth)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withDayOfYear = _class.instanceMethodId(
    r'withDayOfYear',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withDayOfYear = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withDayOfYear(int dayOfYear)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the day-of-year altered.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#withDayOfYear(int) changing the day-of-year of the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param dayOfYear the day-of-year to set in the result, from 1 to 365-366
  ///@return a {@code ZonedDateTime} based on this date with the requested day, not null
  ///@throws DateTimeException if the day-of-year value is invalid,
  ///  or if the day-of-year is invalid for the year
  ZonedDateTime? withDayOfYear(
    int dayOfYear,
  ) {
    return _withDayOfYear(reference.pointer,
            _id_withDayOfYear as jni$_.JMethodIDPtr, dayOfYear)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withHour = _class.instanceMethodId(
    r'withHour',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withHour = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withHour(int hour)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the hour-of-day altered.
  ///
  /// This operates on the local time-line,
  /// {@linkplain LocalDateTime\#withHour(int) changing the time} of the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param hour the hour-of-day to set in the result, from 0 to 23
  ///@return a {@code ZonedDateTime} based on this date-time with the requested hour, not null
  ///@throws DateTimeException if the hour value is invalid
  ZonedDateTime? withHour(
    int hour,
  ) {
    return _withHour(
            reference.pointer, _id_withHour as jni$_.JMethodIDPtr, hour)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withMinute = _class.instanceMethodId(
    r'withMinute',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withMinute = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withMinute(int minute)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the minute-of-hour altered.
  ///
  /// This operates on the local time-line,
  /// {@linkplain LocalDateTime\#withMinute(int) changing the time} of the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param minute the minute-of-hour to set in the result, from 0 to 59
  ///@return a {@code ZonedDateTime} based on this date-time with the requested minute, not null
  ///@throws DateTimeException if the minute value is invalid
  ZonedDateTime? withMinute(
    int minute,
  ) {
    return _withMinute(
            reference.pointer, _id_withMinute as jni$_.JMethodIDPtr, minute)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withSecond = _class.instanceMethodId(
    r'withSecond',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withSecond = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withSecond(int second)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the second-of-minute altered.
  ///
  /// This operates on the local time-line,
  /// {@linkplain LocalDateTime\#withSecond(int) changing the time} of the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param second the second-of-minute to set in the result, from 0 to 59
  ///@return a {@code ZonedDateTime} based on this date-time with the requested second, not null
  ///@throws DateTimeException if the second value is invalid
  ZonedDateTime? withSecond(
    int second,
  ) {
    return _withSecond(
            reference.pointer, _id_withSecond as jni$_.JMethodIDPtr, second)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_withNano = _class.instanceMethodId(
    r'withNano',
    r'(I)Ljava/time/ZonedDateTime;',
  );

  static final _withNano = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int32,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime withNano(int nanoOfSecond)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the nano-of-second altered.
  ///
  /// This operates on the local time-line,
  /// {@linkplain LocalDateTime\#withNano(int) changing the time} of the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param nanoOfSecond the nano-of-second to set in the result, from 0 to 999,999,999
  ///@return a {@code ZonedDateTime} based on this date-time with the requested nanosecond, not null
  ///@throws DateTimeException if the nano value is invalid
  ZonedDateTime? withNano(
    int nanoOfSecond,
  ) {
    return _withNano(
            reference.pointer, _id_withNano as jni$_.JMethodIDPtr, nanoOfSecond)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/ZonedDateTime;',
  );

  static final _truncatedTo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.ZonedDateTime truncatedTo(java.time.temporal.TemporalUnit unit)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the time truncated.
  ///
  /// Truncation returns a copy of the original date-time with fields
  /// smaller than the specified unit set to zero.
  /// For example, truncating with the ChronoUnit\#MINUTES minutes unit
  /// will set the second-of-minute and nano-of-second field to zero.
  ///
  /// The unit must have a {@linkplain TemporalUnit\#getDuration() duration}
  /// that divides into the length of a standard day without remainder.
  /// This includes all supplied time units on ChronoUnit and
  /// ChronoUnit\#DAYS DAYS. Other units throw an exception.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#truncatedTo(TemporalUnit) truncating
  /// the underlying local date-time. This is then converted back to a
  /// {@code ZonedDateTime}, using the zone ID to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param unit the unit to truncate to, not null
  ///@return a {@code ZonedDateTime} based on this date-time with the time truncated, not null
  ///@throws DateTimeException if unable to truncate
  ///@throws UnsupportedTemporalTypeException if the unit is not supported
  ZonedDateTime? truncatedTo(
    jni$_.JObject? unit,
  ) {
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(reference.pointer,
            _id_truncatedTo as jni$_.JMethodIDPtr, _$unit.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/ZonedDateTime;',
  );

  static final _plus = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.ZonedDateTime plus(java.time.temporal.TemporalAmount amountToAdd)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time with the specified amount added.
  ///
  /// This returns a {@code ZonedDateTime}, based on this one, with the specified amount added.
  /// The amount is typically Period or Duration but may be
  /// any other type implementing the TemporalAmount interface.
  ///
  /// The calculation is delegated to the amount object by calling
  /// TemporalAmount\#addTo(Temporal). The amount implementation is free
  /// to implement the addition in any way it wishes, however it typically
  /// calls back to \#plus(long, TemporalUnit). Consult the documentation
  /// of the amount implementation to determine if it can be successfully added.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param amountToAdd the amount to add, not null
  ///@return a {@code ZonedDateTime} based on this date-time with the addition made, not null
  ///@throws DateTimeException if the addition cannot be made
  ///@throws ArithmeticException if numeric overflow occurs
  ZonedDateTime? plus(
    jni$_.JObject? amountToAdd,
  ) {
    final _$amountToAdd = amountToAdd?.reference ?? jni$_.jNullReference;
    return _plus(reference.pointer, _id_plus as jni$_.JMethodIDPtr,
            _$amountToAdd.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/ZonedDateTime;',
  );

  static final _plus$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.ZonedDateTime plus(long amountToAdd, java.time.temporal.TemporalUnit unit)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time with the specified amount added.
  ///
  /// This returns a {@code ZonedDateTime}, based on this one, with the amount
  /// in terms of the unit added. If it is not possible to add the amount, because the
  /// unit is not supported or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoUnit then the addition is implemented here.
  /// The zone is not part of the calculation and will be unchanged in the result.
  /// The calculation for date and time units differ.
  ///
  /// Date units operate on the local time-line.
  /// The period is first added to the local date-time, then converted back
  /// to a zoned date-time using the zone ID.
  /// The conversion uses \#ofLocal(LocalDateTime, ZoneId, ZoneOffset)
  /// with the offset before the addition.
  ///
  /// Time units operate on the instant time-line.
  /// The period is first added to the local date-time, then converted back to
  /// a zoned date-time using the zone ID.
  /// The conversion uses \#ofInstant(LocalDateTime, ZoneOffset, ZoneId)
  /// with the offset before the addition.
  ///
  /// If the field is not a {@code ChronoUnit}, then the result of this method
  /// is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}
  /// passing {@code this} as the argument. In this case, the unit determines
  /// whether and how to perform the addition.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param amountToAdd the amount of the unit to add to the result, may be negative
  ///@param unit the unit of the amount to add, not null
  ///@return a {@code ZonedDateTime} based on this date-time with the specified amount added, not null
  ///@throws DateTimeException if the addition cannot be made
  ///@throws UnsupportedTemporalTypeException if the unit is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  ZonedDateTime? plus$1(
    int amountToAdd,
    jni$_.JObject? unit,
  ) {
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _plus$1(reference.pointer, _id_plus$1 as jni$_.JMethodIDPtr,
            amountToAdd, _$unit.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusYears = _class.instanceMethodId(
    r'plusYears',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusYears = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusYears(long years)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of years added.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#plusYears(long) adding years to the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param years the years to add, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the years added, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? plusYears(
    int years,
  ) {
    return _plusYears(
            reference.pointer, _id_plusYears as jni$_.JMethodIDPtr, years)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusMonths = _class.instanceMethodId(
    r'plusMonths',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusMonths = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusMonths(long months)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of months added.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#plusMonths(long) adding months to the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param months the months to add, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the months added, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? plusMonths(
    int months,
  ) {
    return _plusMonths(
            reference.pointer, _id_plusMonths as jni$_.JMethodIDPtr, months)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusWeeks = _class.instanceMethodId(
    r'plusWeeks',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusWeeks = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusWeeks(long weeks)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of weeks added.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#plusWeeks(long) adding weeks to the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param weeks the weeks to add, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the weeks added, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? plusWeeks(
    int weeks,
  ) {
    return _plusWeeks(
            reference.pointer, _id_plusWeeks as jni$_.JMethodIDPtr, weeks)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusDays = _class.instanceMethodId(
    r'plusDays',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusDays = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusDays(long days)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of days added.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#plusDays(long) adding days to the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param days the days to add, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the days added, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? plusDays(
    int days,
  ) {
    return _plusDays(
            reference.pointer, _id_plusDays as jni$_.JMethodIDPtr, days)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusHours = _class.instanceMethodId(
    r'plusHours',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusHours = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusHours(long hours)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of hours added.
  ///
  /// This operates on the instant time-line, such that adding one hour will
  /// always be a duration of one hour later.
  /// This may cause the local date-time to change by an amount other than one hour.
  /// Note that this is a different approach to that used by days, months and years,
  /// thus adding one day is not the same as adding 24 hours.
  ///
  /// For example, consider a time-zone, such as 'Europe/Paris', where the
  /// Autumn DST cutover means that the local times 02:00 to 02:59 occur twice
  /// changing from offset +02:00 in summer to +01:00 in winter.
  /// <ul>
  /// <li>Adding one hour to 01:30+02:00 will result in 02:30+02:00
  ///     (both in summer time)
  /// <li>Adding one hour to 02:30+02:00 will result in 02:30+01:00
  ///     (moving from summer to winter time)
  /// <li>Adding one hour to 02:30+01:00 will result in 03:30+01:00
  ///     (both in winter time)
  /// <li>Adding three hours to 01:30+02:00 will result in 03:30+01:00
  ///     (moving from summer to winter time)
  /// </ul>
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param hours the hours to add, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the hours added, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? plusHours(
    int hours,
  ) {
    return _plusHours(
            reference.pointer, _id_plusHours as jni$_.JMethodIDPtr, hours)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusMinutes = _class.instanceMethodId(
    r'plusMinutes',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusMinutes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusMinutes(long minutes)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of minutes added.
  ///
  /// This operates on the instant time-line, such that adding one minute will
  /// always be a duration of one minute later.
  /// This may cause the local date-time to change by an amount other than one minute.
  /// Note that this is a different approach to that used by days, months and years.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param minutes the minutes to add, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the minutes added, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? plusMinutes(
    int minutes,
  ) {
    return _plusMinutes(
            reference.pointer, _id_plusMinutes as jni$_.JMethodIDPtr, minutes)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusSeconds = _class.instanceMethodId(
    r'plusSeconds',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusSeconds = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusSeconds(long seconds)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of seconds added.
  ///
  /// This operates on the instant time-line, such that adding one second will
  /// always be a duration of one second later.
  /// This may cause the local date-time to change by an amount other than one second.
  /// Note that this is a different approach to that used by days, months and years.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param seconds the seconds to add, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the seconds added, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? plusSeconds(
    int seconds,
  ) {
    return _plusSeconds(
            reference.pointer, _id_plusSeconds as jni$_.JMethodIDPtr, seconds)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_plusNanos = _class.instanceMethodId(
    r'plusNanos',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _plusNanos = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime plusNanos(long nanos)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of nanoseconds added.
  ///
  /// This operates on the instant time-line, such that adding one nano will
  /// always be a duration of one nano later.
  /// This may cause the local date-time to change by an amount other than one nano.
  /// Note that this is a different approach to that used by days, months and years.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param nanos the nanos to add, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the nanoseconds added, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? plusNanos(
    int nanos,
  ) {
    return _plusNanos(
            reference.pointer, _id_plusNanos as jni$_.JMethodIDPtr, nanos)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/ZonedDateTime;',
  );

  static final _minus = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.ZonedDateTime minus(java.time.temporal.TemporalAmount amountToSubtract)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time with the specified amount subtracted.
  ///
  /// This returns a {@code ZonedDateTime}, based on this one, with the specified amount subtracted.
  /// The amount is typically Period or Duration but may be
  /// any other type implementing the TemporalAmount interface.
  ///
  /// The calculation is delegated to the amount object by calling
  /// TemporalAmount\#subtractFrom(Temporal). The amount implementation is free
  /// to implement the subtraction in any way it wishes, however it typically
  /// calls back to \#minus(long, TemporalUnit). Consult the documentation
  /// of the amount implementation to determine if it can be successfully subtracted.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param amountToSubtract the amount to subtract, not null
  ///@return a {@code ZonedDateTime} based on this date-time with the subtraction made, not null
  ///@throws DateTimeException if the subtraction cannot be made
  ///@throws ArithmeticException if numeric overflow occurs
  ZonedDateTime? minus(
    jni$_.JObject? amountToSubtract,
  ) {
    final _$amountToSubtract =
        amountToSubtract?.reference ?? jni$_.jNullReference;
    return _minus(reference.pointer, _id_minus as jni$_.JMethodIDPtr,
            _$amountToSubtract.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/ZonedDateTime;',
  );

  static final _minus$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.ZonedDateTime minus(long amountToSubtract, java.time.temporal.TemporalUnit unit)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this date-time with the specified amount subtracted.
  ///
  /// This returns a {@code ZonedDateTime}, based on this one, with the amount
  /// in terms of the unit subtracted. If it is not possible to subtract the amount,
  /// because the unit is not supported or for some other reason, an exception is thrown.
  ///
  /// The calculation for date and time units differ.
  ///
  /// Date units operate on the local time-line.
  /// The period is first subtracted from the local date-time, then converted back
  /// to a zoned date-time using the zone ID.
  /// The conversion uses \#ofLocal(LocalDateTime, ZoneId, ZoneOffset)
  /// with the offset before the subtraction.
  ///
  /// Time units operate on the instant time-line.
  /// The period is first subtracted from the local date-time, then converted back to
  /// a zoned date-time using the zone ID.
  /// The conversion uses \#ofInstant(LocalDateTime, ZoneOffset, ZoneId)
  /// with the offset before the subtraction.
  ///
  /// This method is equivalent to \#plus(long, TemporalUnit) with the amount negated.
  /// See that method for a full description of how addition, and thus subtraction, works.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param amountToSubtract the amount of the unit to subtract from the result, may be negative
  ///@param unit the unit of the amount to subtract, not null
  ///@return a {@code ZonedDateTime} based on this date-time with the specified amount subtracted, not null
  ///@throws DateTimeException if the subtraction cannot be made
  ///@throws UnsupportedTemporalTypeException if the unit is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  ZonedDateTime? minus$1(
    int amountToSubtract,
    jni$_.JObject? unit,
  ) {
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _minus$1(reference.pointer, _id_minus$1 as jni$_.JMethodIDPtr,
            amountToSubtract, _$unit.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusYears = _class.instanceMethodId(
    r'minusYears',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusYears = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusYears(long years)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of years subtracted.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#minusYears(long) subtracting years to the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param years the years to subtract, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the years subtracted, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? minusYears(
    int years,
  ) {
    return _minusYears(
            reference.pointer, _id_minusYears as jni$_.JMethodIDPtr, years)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusMonths = _class.instanceMethodId(
    r'minusMonths',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusMonths = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusMonths(long months)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of months subtracted.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#minusMonths(long) subtracting months to the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param months the months to subtract, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the months subtracted, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? minusMonths(
    int months,
  ) {
    return _minusMonths(
            reference.pointer, _id_minusMonths as jni$_.JMethodIDPtr, months)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusWeeks = _class.instanceMethodId(
    r'minusWeeks',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusWeeks = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusWeeks(long weeks)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of weeks subtracted.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#minusWeeks(long) subtracting weeks to the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param weeks the weeks to subtract, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the weeks subtracted, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? minusWeeks(
    int weeks,
  ) {
    return _minusWeeks(
            reference.pointer, _id_minusWeeks as jni$_.JMethodIDPtr, weeks)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusDays = _class.instanceMethodId(
    r'minusDays',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusDays = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusDays(long days)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of days subtracted.
  ///
  /// This operates on the local time-line,
  /// LocalDateTime\#minusDays(long) subtracting days to the local date-time.
  /// This is then converted back to a {@code ZonedDateTime}, using the zone ID
  /// to obtain the offset.
  ///
  /// When converting back to {@code ZonedDateTime}, if the local date-time is in an overlap,
  /// then the offset will be retained if possible, otherwise the earlier offset will be used.
  /// If in a gap, the local date-time will be adjusted forward by the length of the gap.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param days the days to subtract, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the days subtracted, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? minusDays(
    int days,
  ) {
    return _minusDays(
            reference.pointer, _id_minusDays as jni$_.JMethodIDPtr, days)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusHours = _class.instanceMethodId(
    r'minusHours',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusHours = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusHours(long hours)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of hours subtracted.
  ///
  /// This operates on the instant time-line, such that subtracting one hour will
  /// always be a duration of one hour earlier.
  /// This may cause the local date-time to change by an amount other than one hour.
  /// Note that this is a different approach to that used by days, months and years,
  /// thus subtracting one day is not the same as adding 24 hours.
  ///
  /// For example, consider a time-zone, such as 'Europe/Paris', where the
  /// Autumn DST cutover means that the local times 02:00 to 02:59 occur twice
  /// changing from offset +02:00 in summer to +01:00 in winter.
  /// <ul>
  /// <li>Subtracting one hour from 03:30+01:00 will result in 02:30+01:00
  ///     (both in winter time)
  /// <li>Subtracting one hour from 02:30+01:00 will result in 02:30+02:00
  ///     (moving from winter to summer time)
  /// <li>Subtracting one hour from 02:30+02:00 will result in 01:30+02:00
  ///     (both in summer time)
  /// <li>Subtracting three hours from 03:30+01:00 will result in 01:30+02:00
  ///     (moving from winter to summer time)
  /// </ul>
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param hours the hours to subtract, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the hours subtracted, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? minusHours(
    int hours,
  ) {
    return _minusHours(
            reference.pointer, _id_minusHours as jni$_.JMethodIDPtr, hours)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusMinutes = _class.instanceMethodId(
    r'minusMinutes',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusMinutes = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusMinutes(long minutes)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of minutes subtracted.
  ///
  /// This operates on the instant time-line, such that subtracting one minute will
  /// always be a duration of one minute earlier.
  /// This may cause the local date-time to change by an amount other than one minute.
  /// Note that this is a different approach to that used by days, months and years.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param minutes the minutes to subtract, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the minutes subtracted, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? minusMinutes(
    int minutes,
  ) {
    return _minusMinutes(
            reference.pointer, _id_minusMinutes as jni$_.JMethodIDPtr, minutes)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusSeconds = _class.instanceMethodId(
    r'minusSeconds',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusSeconds = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusSeconds(long seconds)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of seconds subtracted.
  ///
  /// This operates on the instant time-line, such that subtracting one second will
  /// always be a duration of one second earlier.
  /// This may cause the local date-time to change by an amount other than one second.
  /// Note that this is a different approach to that used by days, months and years.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param seconds the seconds to subtract, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the seconds subtracted, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? minusSeconds(
    int seconds,
  ) {
    return _minusSeconds(
            reference.pointer, _id_minusSeconds as jni$_.JMethodIDPtr, seconds)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_minusNanos = _class.instanceMethodId(
    r'minusNanos',
    r'(J)Ljava/time/ZonedDateTime;',
  );

  static final _minusNanos = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.ZonedDateTime minusNanos(long nanos)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code ZonedDateTime} with the specified number of nanoseconds subtracted.
  ///
  /// This operates on the instant time-line, such that subtracting one nano will
  /// always be a duration of one nano earlier.
  /// This may cause the local date-time to change by an amount other than one nano.
  /// Note that this is a different approach to that used by days, months and years.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param nanos the nanos to subtract, may be negative
  ///@return a {@code ZonedDateTime} based on this date-time with the nanoseconds subtracted, not null
  ///@throws DateTimeException if the result exceeds the supported date range
  ZonedDateTime? minusNanos(
    int nanos,
  ) {
    return _minusNanos(
            reference.pointer, _id_minusNanos as jni$_.JMethodIDPtr, nanos)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> query)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Queries this date-time using the specified query.
  ///
  /// This queries this date-time using the specified query strategy object.
  /// The {@code TemporalQuery} object defines the logic to be used to
  /// obtain the result. Read the documentation of the query to understand
  /// what the result of this method will be.
  ///
  /// The result of this method is obtained by invoking the
  /// TemporalQuery\#queryFrom(TemporalAccessor) method on the
  /// specified query passing {@code this} as the argument.
  ///@param <R> the type of the result
  ///@param query the query to invoke, not null
  ///@return the query result, null may be returned (defined by the query)
  ///@throws DateTimeException if unable to query (defined by the query)
  ///@throws ArithmeticException if numeric overflow occurs (defined by the query)
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? query, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$query = query?.reference ?? jni$_.jNullReference;
    return _query(
            reference.pointer, _id_query as jni$_.JMethodIDPtr, _$query.pointer)
        .object<$R?>(R.nullableType);
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public long until(java.time.temporal.Temporal endExclusive, java.time.temporal.TemporalUnit unit)`
  ///
  /// Calculates the amount of time until another date-time in terms of the specified unit.
  ///
  /// This calculates the amount of time between two {@code ZonedDateTime}
  /// objects in terms of a single {@code TemporalUnit}.
  /// The start and end points are {@code this} and the specified date-time.
  /// The result will be negative if the end is before the start.
  /// For example, the amount in days between two date-times can be calculated
  /// using {@code startDateTime.until(endDateTime, DAYS)}.
  ///
  /// The {@code Temporal} passed to this method is converted to a
  /// {@code ZonedDateTime} using \#from(TemporalAccessor).
  /// If the time-zone differs between the two zoned date-times, the specified
  /// end date-time is normalized to have the same zone as this date-time.
  ///
  /// The calculation returns a whole number, representing the number of
  /// complete units between the two date-times.
  /// For example, the amount in months between 2012-06-15T00:00Z and 2012-08-14T23:59Z
  /// will only be one month as it is one minute short of two months.
  ///
  /// There are two equivalent ways of using this method.
  /// The first is to invoke this method.
  /// The second is to use TemporalUnit\#between(Temporal, Temporal):
  /// <pre>
  ///   // these two lines are equivalent
  ///   amount = start.until(end, MONTHS);
  ///   amount = MONTHS.between(start, end);
  /// </pre>
  /// The choice should be made based on which makes the code more readable.
  ///
  /// The calculation is implemented in this method for ChronoUnit.
  /// The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},
  /// {@code MINUTES}, {@code HOURS} and {@code HALF_DAYS}, {@code DAYS},
  /// {@code WEEKS}, {@code MONTHS}, {@code YEARS}, {@code DECADES},
  /// {@code CENTURIES}, {@code MILLENNIA} and {@code ERAS} are supported.
  /// Other {@code ChronoUnit} values will throw an exception.
  ///
  /// The calculation for date and time units differ.
  ///
  /// Date units operate on the local time-line, using the local date-time.
  /// For example, the period from noon on day 1 to noon the following day
  /// in days will always be counted as exactly one day, irrespective of whether
  /// there was a daylight savings change or not.
  ///
  /// Time units operate on the instant time-line.
  /// The calculation effectively converts both zoned date-times to instants
  /// and then calculates the period between the instants.
  /// For example, the period from noon on day 1 to noon the following day
  /// in hours may be 23, 24 or 25 hours (or some other amount) depending on
  /// whether there was a daylight savings change or not.
  ///
  /// If the unit is not a {@code ChronoUnit}, then the result of this method
  /// is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}
  /// passing {@code this} as the first argument and the converted input temporal
  /// as the second argument.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param endExclusive the end date, exclusive, which is converted to a {@code ZonedDateTime}, not null
  ///@param unit the unit to measure the amount in, not null
  ///@return the amount of time between this date-time and the end date-time
  ///@throws DateTimeException if the amount cannot be calculated, or the end
  ///  temporal cannot be converted to a {@code ZonedDateTime}
  ///@throws UnsupportedTemporalTypeException if the unit is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  int until(
    jni$_.JObject? endExclusive,
    jni$_.JObject? unit,
  ) {
    final _$endExclusive = endExclusive?.reference ?? jni$_.jNullReference;
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _until(reference.pointer, _id_until as jni$_.JMethodIDPtr,
            _$endExclusive.pointer, _$unit.pointer)
        .long;
  }

  static final _id_format = _class.instanceMethodId(
    r'format',
    r'(Ljava/time/format/DateTimeFormatter;)Ljava/lang/String;',
  );

  static final _format = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.lang.String format(java.time.format.DateTimeFormatter formatter)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Formats this date-time using the specified formatter.
  ///
  /// This date-time will be passed to the formatter to produce a string.
  ///@param formatter the formatter to use, not null
  ///@return the formatted date-time string, not null
  ///@throws DateTimeException if an error occurs during printing
  jni$_.JString? format(
    jni$_.JObject? formatter,
  ) {
    final _$formatter = formatter?.reference ?? jni$_.jNullReference;
    return _format(reference.pointer, _id_format as jni$_.JMethodIDPtr,
            _$formatter.pointer)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_toOffsetDateTime = _class.instanceMethodId(
    r'toOffsetDateTime',
    r'()Ljava/time/OffsetDateTime;',
  );

  static final _toOffsetDateTime = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.OffsetDateTime toOffsetDateTime()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Converts this date-time to an {@code OffsetDateTime}.
  ///
  /// This creates an offset date-time using the local date-time and offset.
  /// The zone ID is ignored.
  ///@return an offset date-time representing the same local date-time and offset, not null
  jni$_.JObject? toOffsetDateTime() {
    return _toOffsetDateTime(
            reference.pointer, _id_toOffsetDateTime as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object obj)`
  ///
  /// Checks if this date-time is equal to another date-time.
  ///
  /// The comparison is based on the offset date-time and the zone.
  /// Only objects of type {@code ZonedDateTime} are compared, other types return false.
  ///@param obj the object to check, null returns false
  ///@return true if this is equal to the other date-time
  bool equals(
    jni$_.JObject? obj,
  ) {
    final _$obj = obj?.reference ?? jni$_.jNullReference;
    return _equals(
            reference.pointer, _id_equals as jni$_.JMethodIDPtr, _$obj.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  ///
  /// A hash code for this date-time.
  ///@return a suitable hash code
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Outputs this date-time as a {@code String}, such as
  /// {@code 2007-12-03T10:15:30+01:00[Europe/Paris]}.
  ///
  /// The format consists of the {@code LocalDateTime} followed by the {@code ZoneOffset}.
  /// If the {@code ZoneId} is not the same as the offset, then the ID is output.
  /// The output is compatible with ISO-8601 if the offset and ID are the same.
  ///@return a string representation of this date-time, not null
  jni$_.JString? toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $ZonedDateTime$NullableType extends jni$_.JObjType<ZonedDateTime?> {
  @jni$_.internal
  const $ZonedDateTime$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZonedDateTime;';

  @jni$_.internal
  @core$_.override
  ZonedDateTime? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : ZonedDateTime.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZonedDateTime?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZonedDateTime$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZonedDateTime$NullableType) &&
        other is $ZonedDateTime$NullableType;
  }
}

final class $ZonedDateTime$Type extends jni$_.JObjType<ZonedDateTime> {
  @jni$_.internal
  const $ZonedDateTime$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZonedDateTime;';

  @jni$_.internal
  @core$_.override
  ZonedDateTime fromReference(jni$_.JReference reference) =>
      ZonedDateTime.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZonedDateTime?> get nullableType =>
      const $ZonedDateTime$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($ZonedDateTime$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZonedDateTime$Type) &&
        other is $ZonedDateTime$Type;
  }
}

/// from: `java.time.ZoneOffset`
///
/// A time-zone offset from Greenwich/UTC, such as {@code +02:00}.
///
/// A time-zone offset is the amount of time that a time-zone differs from Greenwich/UTC.
/// This is usually a fixed number of hours and minutes.
///
/// Different parts of the world have different time-zone offsets.
/// The rules for how offsets vary by place and time of year are captured in the
/// ZoneId class.
///
/// For example, Paris is one hour ahead of Greenwich/UTC in winter and two hours
/// ahead in summer. The {@code ZoneId} instance for Paris will reference two
/// {@code ZoneOffset} instances - a {@code +01:00} instance for winter,
/// and a {@code +02:00} instance for summer.
///
/// In 2008, time-zone offsets around the world extended from -12:00 to +14:00.
/// To prevent any problems with that range being extended, yet still provide
/// validation, the range of offsets is restricted to -18:00 to 18:00 inclusive.
///
/// This class is designed for use with the ISO calendar system.
/// The fields of hours, minutes and seconds make assumptions that are valid for the
/// standard ISO definitions of those fields. This class may be used with other
/// calendar systems providing the definition of the time fields matches those
/// of the ISO calendar system.
///
/// Instances of {@code ZoneOffset} must be compared using \#equals.
/// Implementations may choose to cache certain common offsets, however
/// applications must not rely on such caching.
///
///
/// This is a <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>
/// class; use of identity-sensitive operations (including reference equality
/// ({@code ==}), identity hash code, or synchronization) on instances of
/// {@code ZoneOffset} may have unpredictable results and should be avoided.
/// The {@code equals} method should be used for comparisons.
///@implSpec This class is immutable and thread-safe.
///@since 1.8
class ZoneOffset extends ZoneId {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<ZoneOffset> $type;

  @jni$_.internal
  ZoneOffset.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/ZoneOffset');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $ZoneOffset$NullableType();
  static const type = $ZoneOffset$Type();
  static final _id_UTC = _class.staticFieldId(
    r'UTC',
    r'Ljava/time/ZoneOffset;',
  );

  /// from: `static public final java.time.ZoneOffset UTC`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The time-zone offset for UTC, with an ID of 'Z'.
  static ZoneOffset? get UTC =>
      _id_UTC.get(_class, const $ZoneOffset$NullableType());

  static final _id_MIN = _class.staticFieldId(
    r'MIN',
    r'Ljava/time/ZoneOffset;',
  );

  /// from: `static public final java.time.ZoneOffset MIN`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constant for the minimum supported offset.
  static ZoneOffset? get MIN =>
      _id_MIN.get(_class, const $ZoneOffset$NullableType());

  static final _id_MAX = _class.staticFieldId(
    r'MAX',
    r'Ljava/time/ZoneOffset;',
  );

  /// from: `static public final java.time.ZoneOffset MAX`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constant for the maximum supported offset.
  static ZoneOffset? get MAX =>
      _id_MAX.get(_class, const $ZoneOffset$NullableType());

  static final _id_of$2 = _class.staticMethodId(
    r'of',
    r'(Ljava/lang/String;)Ljava/time/ZoneOffset;',
  );

  static final _of$2 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZoneOffset of(java.lang.String offsetId)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneOffset} using the ID.
  ///
  /// This method parses the string ID of a {@code ZoneOffset} to
  /// return an instance. The parsing accepts all the formats generated by
  /// \#getId(), plus some additional formats:
  /// <ul>
  /// <li>{@code Z} - for UTC
  /// <li>{@code +h}
  /// <li>{@code +hh}
  /// <li>{@code +hh:mm}
  /// <li>{@code -hh:mm}
  /// <li>{@code +hhmm}
  /// <li>{@code -hhmm}
  /// <li>{@code +hh:mm:ss}
  /// <li>{@code -hh:mm:ss}
  /// <li>{@code +hhmmss}
  /// <li>{@code -hhmmss}
  /// </ul>
  /// Note that &plusmn; means either the plus or minus symbol.
  ///
  /// The ID of the returned offset will be normalized to one of the formats
  /// described by \#getId().
  ///
  /// The maximum supported range is from +18:00 to -18:00 inclusive.
  ///@param offsetId the offset ID, not null
  ///@return the zone-offset, not null
  ///@throws DateTimeException if the offset ID is invalid
  static ZoneOffset? of$2(
    jni$_.JString? offsetId,
  ) {
    final _$offsetId = offsetId?.reference ?? jni$_.jNullReference;
    return _of$2(_class.reference.pointer, _id_of$2 as jni$_.JMethodIDPtr,
            _$offsetId.pointer)
        .object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_ofHours = _class.staticMethodId(
    r'ofHours',
    r'(I)Ljava/time/ZoneOffset;',
  );

  static final _ofHours = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.time.ZoneOffset ofHours(int hours)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneOffset} using an offset in hours.
  ///@param hours the time-zone offset in hours, from -18 to +18
  ///@return the zone-offset, not null
  ///@throws DateTimeException if the offset is not in the required range
  static ZoneOffset? ofHours(
    int hours,
  ) {
    return _ofHours(
            _class.reference.pointer, _id_ofHours as jni$_.JMethodIDPtr, hours)
        .object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_ofHoursMinutes = _class.staticMethodId(
    r'ofHoursMinutes',
    r'(II)Ljava/time/ZoneOffset;',
  );

  static final _ofHoursMinutes = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `static public java.time.ZoneOffset ofHoursMinutes(int hours, int minutes)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneOffset} using an offset in
  /// hours and minutes.
  ///
  /// The sign of the hours and minutes components must match.
  /// Thus, if the hours is negative, the minutes must be negative or zero.
  /// If the hours is zero, the minutes may be positive, negative or zero.
  ///@param hours the time-zone offset in hours, from -18 to +18
  ///@param minutes the time-zone offset in minutes, from 0 to &plusmn;59, sign matches hours
  ///@return the zone-offset, not null
  ///@throws DateTimeException if the offset is not in the required range
  static ZoneOffset? ofHoursMinutes(
    int hours,
    int minutes,
  ) {
    return _ofHoursMinutes(_class.reference.pointer,
            _id_ofHoursMinutes as jni$_.JMethodIDPtr, hours, minutes)
        .object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_ofHoursMinutesSeconds = _class.staticMethodId(
    r'ofHoursMinutesSeconds',
    r'(III)Ljava/time/ZoneOffset;',
  );

  static final _ofHoursMinutesSeconds = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int32, jni$_.Int32, jni$_.Int32)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int, int)>();

  /// from: `static public java.time.ZoneOffset ofHoursMinutesSeconds(int hours, int minutes, int seconds)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneOffset} using an offset in
  /// hours, minutes and seconds.
  ///
  /// The sign of the hours, minutes and seconds components must match.
  /// Thus, if the hours is negative, the minutes and seconds must be negative or zero.
  ///@param hours the time-zone offset in hours, from -18 to +18
  ///@param minutes the time-zone offset in minutes, from 0 to &plusmn;59, sign matches hours and seconds
  ///@param seconds the time-zone offset in seconds, from 0 to &plusmn;59, sign matches hours and minutes
  ///@return the zone-offset, not null
  ///@throws DateTimeException if the offset is not in the required range
  static ZoneOffset? ofHoursMinutesSeconds(
    int hours,
    int minutes,
    int seconds,
  ) {
    return _ofHoursMinutesSeconds(
            _class.reference.pointer,
            _id_ofHoursMinutesSeconds as jni$_.JMethodIDPtr,
            hours,
            minutes,
            seconds)
        .object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_from$1 = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/ZoneOffset;',
  );

  static final _from$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.ZoneOffset from(java.time.temporal.TemporalAccessor temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneOffset} from a temporal object.
  ///
  /// This obtains an offset based on the specified temporal.
  /// A {@code TemporalAccessor} represents an arbitrary set of date and time information,
  /// which this factory converts to an instance of {@code ZoneOffset}.
  ///
  /// A {@code TemporalAccessor} represents some form of date and time information.
  /// This factory converts the arbitrary temporal object to an instance of {@code ZoneOffset}.
  ///
  /// The conversion uses the TemporalQueries\#offset() query, which relies
  /// on extracting the ChronoField\#OFFSET_SECONDS OFFSET_SECONDS field.
  ///
  /// This method matches the signature of the functional interface TemporalQuery
  /// allowing it to be used as a query via method reference, {@code ZoneOffset::from}.
  ///@param temporal the temporal object to convert, not null
  ///@return the zone-offset, not null
  ///@throws DateTimeException if unable to convert to an {@code ZoneOffset}
  static ZoneOffset? from$1(
    jni$_.JObject? temporal,
  ) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _from$1(_class.reference.pointer, _id_from$1 as jni$_.JMethodIDPtr,
            _$temporal.pointer)
        .object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_ofTotalSeconds = _class.staticMethodId(
    r'ofTotalSeconds',
    r'(I)Ljava/time/ZoneOffset;',
  );

  static final _ofTotalSeconds = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.time.ZoneOffset ofTotalSeconds(int totalSeconds)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code ZoneOffset} specifying the total offset in seconds
  ///
  /// The offset must be in the range {@code -18:00} to {@code +18:00}, which corresponds to -64800 to +64800.
  ///@param totalSeconds the total time-zone offset in seconds, from -64800 to +64800
  ///@return the ZoneOffset, not null
  ///@throws DateTimeException if the offset is not in the required range
  static ZoneOffset? ofTotalSeconds(
    int totalSeconds,
  ) {
    return _ofTotalSeconds(_class.reference.pointer,
            _id_ofTotalSeconds as jni$_.JMethodIDPtr, totalSeconds)
        .object<ZoneOffset?>(const $ZoneOffset$NullableType());
  }

  static final _id_getTotalSeconds = _class.instanceMethodId(
    r'getTotalSeconds',
    r'()I',
  );

  static final _getTotalSeconds = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getTotalSeconds()`
  ///
  /// Gets the total zone offset in seconds.
  ///
  /// This is the primary way to access the offset amount.
  /// It returns the total of the hours, minutes and seconds fields as a
  /// single offset that can be added to a time.
  ///@return the total zone offset amount in seconds
  int getTotalSeconds() {
    return _getTotalSeconds(
            reference.pointer, _id_getTotalSeconds as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_getId = _class.instanceMethodId(
    r'getId',
    r'()Ljava/lang/String;',
  );

  static final _getId = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String getId()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the normalized zone offset ID.
  ///
  /// The ID is minor variation to the standard ISO-8601 formatted string
  /// for the offset. There are three formats:
  /// <ul>
  /// <li>{@code Z} - for UTC (ISO-8601)
  /// <li>{@code +hh:mm} or {@code -hh:mm} - if the seconds are zero (ISO-8601)
  /// <li>{@code +hh:mm:ss} or {@code -hh:mm:ss} - if the seconds are non-zero (not ISO-8601)
  /// </ul>
  ///@return the zone offset ID, not null
  jni$_.JString? getId() {
    return _getId(reference.pointer, _id_getId as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }

  static final _id_getRules = _class.instanceMethodId(
    r'getRules',
    r'()Ljava/time/zone/ZoneRules;',
  );

  static final _getRules = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.time.zone.ZoneRules getRules()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the associated time-zone rules.
  ///
  /// The rules will always return this offset when queried.
  /// The implementation class is immutable, thread-safe and serializable.
  ///@return the rules, not null
  jni$_.JObject? getRules() {
    return _getRules(reference.pointer, _id_getRules as jni$_.JMethodIDPtr)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField field)`
  ///
  /// Checks if the specified field is supported.
  ///
  /// This checks if this offset can be queried for the specified field.
  /// If false, then calling the \#range(TemporalField) range and
  /// \#get(TemporalField) get methods will throw an exception.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The {@code OFFSET_SECONDS} field returns true.
  /// All other {@code ChronoField} instances will return false.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}
  /// passing {@code this} as the argument.
  /// Whether the field is supported is determined by the field.
  ///@param field the field to check, null returns false
  ///@return true if the field is supported on this offset, false if not
  bool isSupported(
    jni$_.JObject? field,
  ) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _isSupported(reference.pointer,
            _id_isSupported as jni$_.JMethodIDPtr, _$field.pointer)
        .boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField field)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the range of valid values for the specified field.
  ///
  /// The range object expresses the minimum and maximum valid values for a field.
  /// This offset is used to enhance the accuracy of the returned range.
  /// If it is not possible to return the range, because the field is not supported
  /// or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The \#isSupported(TemporalField) supported fields will return
  /// appropriate range instances.
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}
  /// passing {@code this} as the argument.
  /// Whether the range can be obtained is determined by the field.
  ///@param field the field to query the range for, not null
  ///@return the range of valid values for the field, not null
  ///@throws DateTimeException if the range for the field cannot be obtained
  ///@throws UnsupportedTemporalTypeException if the field is not supported
  jni$_.JObject? range(
    jni$_.JObject? field,
  ) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _range(
            reference.pointer, _id_range as jni$_.JMethodIDPtr, _$field.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int get(java.time.temporal.TemporalField field)`
  ///
  /// Gets the value of the specified field from this offset as an {@code int}.
  ///
  /// This queries this offset for the value of the specified field.
  /// The returned value will always be within the valid range of values for the field.
  /// If it is not possible to return the value, because the field is not supported
  /// or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The {@code OFFSET_SECONDS} field returns the value of the offset.
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
  /// passing {@code this} as the argument. Whether the value can be obtained,
  /// and what the value represents, is determined by the field.
  ///@param field the field to get, not null
  ///@return the value for the field
  ///@throws DateTimeException if a value for the field cannot be obtained or
  ///         the value is outside the range of valid values for the field
  ///@throws UnsupportedTemporalTypeException if the field is not supported or
  ///         the range of values exceeds an {@code int}
  ///@throws ArithmeticException if numeric overflow occurs
  int get(
    jni$_.JObject? field,
  ) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _get(
            reference.pointer, _id_get as jni$_.JMethodIDPtr, _$field.pointer)
        .integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public long getLong(java.time.temporal.TemporalField field)`
  ///
  /// Gets the value of the specified field from this offset as a {@code long}.
  ///
  /// This queries this offset for the value of the specified field.
  /// If it is not possible to return the value, because the field is not supported
  /// or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The {@code OFFSET_SECONDS} field returns the value of the offset.
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
  /// passing {@code this} as the argument. Whether the value can be obtained,
  /// and what the value represents, is determined by the field.
  ///@param field the field to get, not null
  ///@return the value for the field
  ///@throws DateTimeException if a value for the field cannot be obtained
  ///@throws UnsupportedTemporalTypeException if the field is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  int getLong(
    jni$_.JObject? field,
  ) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _getLong(reference.pointer, _id_getLong as jni$_.JMethodIDPtr,
            _$field.pointer)
        .long;
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> query)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Queries this offset using the specified query.
  ///
  /// This queries this offset using the specified query strategy object.
  /// The {@code TemporalQuery} object defines the logic to be used to
  /// obtain the result. Read the documentation of the query to understand
  /// what the result of this method will be.
  ///
  /// The result of this method is obtained by invoking the
  /// TemporalQuery\#queryFrom(TemporalAccessor) method on the
  /// specified query passing {@code this} as the argument.
  ///@param <R> the type of the result
  ///@param query the query to invoke, not null
  ///@return the query result, null may be returned (defined by the query)
  ///@throws DateTimeException if unable to query (defined by the query)
  ///@throws ArithmeticException if numeric overflow occurs (defined by the query)
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? query, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$query = query?.reference ?? jni$_.jNullReference;
    return _query(
            reference.pointer, _id_query as jni$_.JMethodIDPtr, _$query.pointer)
        .object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Adjusts the specified temporal object to have the same offset as this object.
  ///
  /// This returns a temporal object of the same observable type as the input
  /// with the offset changed to be the same as this.
  ///
  /// The adjustment is equivalent to using Temporal\#with(TemporalField, long)
  /// passing ChronoField\#OFFSET_SECONDS as the field.
  ///
  /// In most cases, it is clearer to reverse the calling pattern by using
  /// Temporal\#with(TemporalAdjuster):
  /// <pre>
  ///   // these two lines are equivalent, but the second approach is recommended
  ///   temporal = thisOffset.adjustInto(temporal);
  ///   temporal = temporal.with(thisOffset);
  /// </pre>
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param temporal the target object to be adjusted, not null
  ///@return the adjusted object, not null
  ///@throws DateTimeException if unable to make the adjustment
  ///@throws ArithmeticException if numeric overflow occurs
  jni$_.JObject? adjustInto(
    jni$_.JObject? temporal,
  ) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(reference.pointer, _id_adjustInto as jni$_.JMethodIDPtr,
            _$temporal.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/ZoneOffset;)I',
  );

  static final _compareTo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int compareTo(java.time.ZoneOffset other)`
  ///
  /// Compares this offset to another offset in descending order.
  ///
  /// The offsets are compared in the order that they occur for the same time
  /// of day around the world. Thus, an offset of {@code +10:00} comes before an
  /// offset of {@code +09:00} and so on down to {@code -18:00}.
  ///
  /// The comparison is "consistent with equals", as defined by Comparable.
  ///@param other the other date to compare to, not null
  ///@return the comparator value, negative if less, positive if greater
  ///@throws NullPointerException if {@code other} is null
  int compareTo(
    ZoneOffset? other,
  ) {
    final _$other = other?.reference ?? jni$_.jNullReference;
    return _compareTo(reference.pointer, _id_compareTo as jni$_.JMethodIDPtr,
            _$other.pointer)
        .integer;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object obj)`
  ///
  /// Checks if this offset is equal to another offset.
  ///
  /// The comparison is based on the amount of the offset in seconds.
  /// This is equivalent to a comparison by ID.
  ///@param obj the object to check, null returns false
  ///@return true if this is equal to the other offset
  bool equals(
    jni$_.JObject? obj,
  ) {
    final _$obj = obj?.reference ?? jni$_.jNullReference;
    return _equals(
            reference.pointer, _id_equals as jni$_.JMethodIDPtr, _$obj.pointer)
        .boolean;
  }

  static final _id_hashCode1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  ///
  /// A hash code for this offset.
  ///@return a suitable hash code
  int hashCode1() {
    return _hashCode1(reference.pointer, _id_hashCode1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_toString1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Outputs this offset as a {@code String}, using the normalized ID.
  ///@return a string representation of this offset, not null
  jni$_.JString? toString1() {
    return _toString1(reference.pointer, _id_toString1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $ZoneOffset$NullableType extends jni$_.JObjType<ZoneOffset?> {
  @jni$_.internal
  const $ZoneOffset$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZoneOffset;';

  @jni$_.internal
  @core$_.override
  ZoneOffset? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : ZoneOffset.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ZoneId$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneOffset?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ZoneOffset$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoneOffset$NullableType) &&
        other is $ZoneOffset$NullableType;
  }
}

final class $ZoneOffset$Type extends jni$_.JObjType<ZoneOffset> {
  @jni$_.internal
  const $ZoneOffset$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/ZoneOffset;';

  @jni$_.internal
  @core$_.override
  ZoneOffset fromReference(jni$_.JReference reference) =>
      ZoneOffset.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const $ZoneId$NullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<ZoneOffset?> get nullableType =>
      const $ZoneOffset$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($ZoneOffset$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($ZoneOffset$Type) && other is $ZoneOffset$Type;
  }
}

/// from: `java.time.Instant`
///
/// An instantaneous point on the time-line.
///
/// This class models a single instantaneous point on the time-line.
/// This might be used to record event time-stamps in the application.
///
/// The range of an instant requires the storage of a number larger than a {@code long}.
/// To achieve this, the class stores a {@code long} representing epoch-seconds and an
/// {@code int} representing nanosecond-of-second, which will always be between 0 and 999,999,999.
/// The epoch-seconds are measured from the standard Java epoch of {@code 1970-01-01T00:00:00Z}
/// where instants after the epoch have positive values, and earlier instants have negative values.
/// For both the epoch-second and nanosecond parts, a larger value is always later on the time-line
/// than a smaller value.
///
/// <h3>Time-scale</h3>
///
/// The length of the solar day is the standard way that humans measure time.
/// This has traditionally been subdivided into 24 hours of 60 minutes of 60 seconds,
/// forming a 86400 second day.
///
/// Modern timekeeping is based on atomic clocks which precisely define an SI second
/// relative to the transitions of a Caesium atom. The length of an SI second was defined
/// to be very close to the 86400th fraction of a day.
///
/// Unfortunately, as the Earth rotates the length of the day varies.
/// In addition, over time the average length of the day is getting longer as the Earth slows.
/// As a result, the length of a solar day in 2012 is slightly longer than 86400 SI seconds.
/// The actual length of any given day and the amount by which the Earth is slowing
/// are not predictable and can only be determined by measurement.
/// The UT1 time-scale captures the accurate length of day, but is only available some
/// time after the day has completed.
///
/// The UTC time-scale is a standard approach to bundle up all the additional fractions
/// of a second from UT1 into whole seconds, known as <i>leap-seconds</i>.
/// A leap-second may be added or removed depending on the Earth's rotational changes.
/// As such, UTC permits a day to have 86399 SI seconds or 86401 SI seconds where
/// necessary in order to keep the day aligned with the Sun.
///
/// The modern UTC time-scale was introduced in 1972, introducing the concept of whole leap-seconds.
/// Between 1958 and 1972, the definition of UTC was complex, with minor sub-second leaps and
/// alterations to the length of the notional second. As of 2012, discussions are underway
/// to change the definition of UTC again, with the potential to remove leap seconds or
/// introduce other changes.
///
/// Given the complexity of accurate timekeeping described above, this Java API defines
/// its own time-scale, the <i>Java Time-Scale</i>.
///
/// The Java Time-Scale divides each calendar day into exactly 86400
/// subdivisions, known as seconds.  These seconds may differ from the
/// SI second.  It closely matches the de facto international civil time
/// scale, the definition of which changes from time to time.
///
/// The Java Time-Scale has slightly different definitions for different
/// segments of the time-line, each based on the consensus international
/// time scale that is used as the basis for civil time. Whenever the
/// internationally-agreed time scale is modified or replaced, a new
/// segment of the Java Time-Scale must be defined for it.  Each segment
/// must meet these requirements:
/// <ul>
/// <li>the Java Time-Scale shall closely match the underlying international
///  civil time scale;</li>
/// <li>the Java Time-Scale shall exactly match the international civil
///  time scale at noon each day;</li>
/// <li>the Java Time-Scale shall have a precisely-defined relationship to
///  the international civil time scale.</li>
/// </ul>
/// There are currently, as of 2013, two segments in the Java time-scale.
///
/// For the segment from 1972-11-03 (exact boundary discussed below) until
/// further notice, the consensus international time scale is UTC (with
/// leap seconds).  In this segment, the Java Time-Scale is identical to
/// <a href="http://www.cl.cam.ac.uk/~mgk25/time/utc-sls/">UTC-SLS</a>.
/// This is identical to UTC on days that do not have a leap second.
/// On days that do have a leap second, the leap second is spread equally
/// over the last 1000 seconds of the day, maintaining the appearance of
/// exactly 86400 seconds per day.
///
/// For the segment prior to 1972-11-03, extending back arbitrarily far,
/// the consensus international time scale is defined to be UT1, applied
/// proleptically, which is equivalent to the (mean) solar time on the
/// prime meridian (Greenwich). In this segment, the Java Time-Scale is
/// identical to the consensus international time scale. The exact
/// boundary between the two segments is the instant where UT1 = UTC
/// between 1972-11-03T00:00 and 1972-11-04T12:00.
///
/// Implementations of the Java time-scale using the JSR-310 API are not
/// required to provide any clock that is sub-second accurate, or that
/// progresses monotonically or smoothly. Implementations are therefore
/// not required to actually perform the UTC-SLS slew or to otherwise be
/// aware of leap seconds. JSR-310 does, however, require that
/// implementations must document the approach they use when defining a
/// clock representing the current instant.
/// See Clock for details on the available clocks.
///
/// The Java time-scale is used for all date-time classes.
/// This includes {@code Instant}, {@code LocalDate}, {@code LocalTime}, {@code OffsetDateTime},
/// {@code ZonedDateTime} and {@code Duration}.
///
///
/// This is a <a href="{@docRoot}/java.base/java/lang/doc-files/ValueBased.html">value-based</a>
/// class; use of identity-sensitive operations (including reference equality
/// ({@code ==}), identity hash code, or synchronization) on instances of
/// {@code Instant} may have unpredictable results and should be avoided.
/// The {@code equals} method should be used for comparisons.
///@implSpec This class is immutable and thread-safe.
///@since 1.8
class Instant extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JObjType<Instant> $type;

  @jni$_.internal
  Instant.fromReference(
    jni$_.JReference reference,
  )   : $type = type,
        super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'java/time/Instant');

  /// The type which includes information such as the signature of this class.
  static const nullableType = $Instant$NullableType();
  static const type = $Instant$Type();
  static final _id_EPOCH = _class.staticFieldId(
    r'EPOCH',
    r'Ljava/time/Instant;',
  );

  /// from: `static public final java.time.Instant EPOCH`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Constant for the 1970-01-01T00:00:00Z epoch instant.
  static Instant? get EPOCH =>
      _id_EPOCH.get(_class, const $Instant$NullableType());

  static final _id_MIN = _class.staticFieldId(
    r'MIN',
    r'Ljava/time/Instant;',
  );

  /// from: `static public final java.time.Instant MIN`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The minimum supported {@code Instant}, '-1000000000-01-01T00:00Z'.
  /// This could be used by an application as a "far past" instant.
  ///
  /// This is one year earlier than the minimum {@code LocalDateTime}.
  /// This provides sufficient values to handle the range of {@code ZoneOffset}
  /// which affect the instant in addition to the local date-time.
  /// The value is also chosen such that the value of the year fits in
  /// an {@code int}.
  static Instant? get MIN => _id_MIN.get(_class, const $Instant$NullableType());

  static final _id_MAX = _class.staticFieldId(
    r'MAX',
    r'Ljava/time/Instant;',
  );

  /// from: `static public final java.time.Instant MAX`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// The maximum supported {@code Instant}, '1000000000-12-31T23:59:59.999999999Z'.
  /// This could be used by an application as a "far future" instant.
  ///
  /// This is one year later than the maximum {@code LocalDateTime}.
  /// This provides sufficient values to handle the range of {@code ZoneOffset}
  /// which affect the instant in addition to the local date-time.
  /// The value is also chosen such that the value of the year fits in
  /// an {@code int}.
  static Instant? get MAX => _id_MAX.get(_class, const $Instant$NullableType());

  static final _id_now = _class.staticMethodId(
    r'now',
    r'()Ljava/time/Instant;',
  );

  static final _now = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `static public java.time.Instant now()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains the current instant from the system clock.
  ///
  /// This will query the Clock\#systemUTC() system UTC clock to
  /// obtain the current instant.
  ///
  /// Using this method will prevent the ability to use an alternate time-source for
  /// testing because the clock is effectively hard-coded.
  ///@return the current instant using the system clock, not null
  static Instant? now() {
    return _now(_class.reference.pointer, _id_now as jni$_.JMethodIDPtr)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_now$1 = _class.staticMethodId(
    r'now',
    r'(Ljava/time/Clock;)Ljava/time/Instant;',
  );

  static final _now$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.Instant now(java.time.Clock clock)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains the current instant from the specified clock.
  ///
  /// This will query the specified clock to obtain the current time.
  ///
  /// Using this method allows the use of an alternate clock for testing.
  /// The alternate clock may be introduced using Clock dependency injection.
  ///@param clock the clock to use, not null
  ///@return the current instant, not null
  static Instant? now$1(
    jni$_.JObject? clock,
  ) {
    final _$clock = clock?.reference ?? jni$_.jNullReference;
    return _now$1(_class.reference.pointer, _id_now$1 as jni$_.JMethodIDPtr,
            _$clock.pointer)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_ofEpochSecond = _class.staticMethodId(
    r'ofEpochSecond',
    r'(J)Ljava/time/Instant;',
  );

  static final _ofEpochSecond = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.time.Instant ofEpochSecond(long epochSecond)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code Instant} using seconds from the
  /// epoch of 1970-01-01T00:00:00Z.
  ///
  /// The nanosecond field is set to zero.
  ///@param epochSecond the number of seconds from 1970-01-01T00:00:00Z
  ///@return an instant, not null
  ///@throws DateTimeException if the instant exceeds the maximum or minimum instant
  static Instant? ofEpochSecond(
    int epochSecond,
  ) {
    return _ofEpochSecond(_class.reference.pointer,
            _id_ofEpochSecond as jni$_.JMethodIDPtr, epochSecond)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_ofEpochSecond$1 = _class.staticMethodId(
    r'ofEpochSecond',
    r'(JJ)Ljava/time/Instant;',
  );

  static final _ofEpochSecond$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Int64, jni$_.Int64)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, int)>();

  /// from: `static public java.time.Instant ofEpochSecond(long epochSecond, long nanoAdjustment)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code Instant} using seconds from the
  /// epoch of 1970-01-01T00:00:00Z and nanosecond fraction of second.
  ///
  /// This method allows an arbitrary number of nanoseconds to be passed in.
  /// The factory will alter the values of the second and nanosecond in order
  /// to ensure that the stored nanosecond is in the range 0 to 999,999,999.
  /// For example, the following will result in exactly the same instant:
  /// <pre>
  ///  Instant.ofEpochSecond(3, 1);
  ///  Instant.ofEpochSecond(4, -999_999_999);
  ///  Instant.ofEpochSecond(2, 1000_000_001);
  /// </pre>
  ///@param epochSecond the number of seconds from 1970-01-01T00:00:00Z
  ///@param nanoAdjustment the nanosecond adjustment to the number of seconds, positive or negative
  ///@return an instant, not null
  ///@throws DateTimeException if the instant exceeds the maximum or minimum instant
  ///@throws ArithmeticException if numeric overflow occurs
  static Instant? ofEpochSecond$1(
    int epochSecond,
    int nanoAdjustment,
  ) {
    return _ofEpochSecond$1(
            _class.reference.pointer,
            _id_ofEpochSecond$1 as jni$_.JMethodIDPtr,
            epochSecond,
            nanoAdjustment)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_ofEpochMilli = _class.staticMethodId(
    r'ofEpochMilli',
    r'(J)Ljava/time/Instant;',
  );

  static final _ofEpochMilli = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int64,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `static public java.time.Instant ofEpochMilli(long epochMilli)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code Instant} using milliseconds from the
  /// epoch of 1970-01-01T00:00:00Z.
  ///
  /// The seconds and nanoseconds are extracted from the specified milliseconds.
  ///@param epochMilli the number of milliseconds from 1970-01-01T00:00:00Z
  ///@return an instant, not null
  ///@throws DateTimeException if the instant exceeds the maximum or minimum instant
  static Instant? ofEpochMilli(
    int epochMilli,
  ) {
    return _ofEpochMilli(_class.reference.pointer,
            _id_ofEpochMilli as jni$_.JMethodIDPtr, epochMilli)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_from = _class.staticMethodId(
    r'from',
    r'(Ljava/time/temporal/TemporalAccessor;)Ljava/time/Instant;',
  );

  static final _from = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.Instant from(java.time.temporal.TemporalAccessor temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code Instant} from a temporal object.
  ///
  /// This obtains an instant based on the specified temporal.
  /// A {@code TemporalAccessor} represents an arbitrary set of date and time information,
  /// which this factory converts to an instance of {@code Instant}.
  ///
  /// The conversion extracts the ChronoField\#INSTANT_SECONDS INSTANT_SECONDS
  /// and ChronoField\#NANO_OF_SECOND NANO_OF_SECOND fields.
  ///
  /// This method matches the signature of the functional interface TemporalQuery
  /// allowing it to be used as a query via method reference, {@code Instant::from}.
  ///@param temporal the temporal object to convert, not null
  ///@return the instant, not null
  ///@throws DateTimeException if unable to convert to an {@code Instant}
  static Instant? from(
    jni$_.JObject? temporal,
  ) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _from(_class.reference.pointer, _id_from as jni$_.JMethodIDPtr,
            _$temporal.pointer)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/CharSequence;)Ljava/time/Instant;',
  );

  static final _parse = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallStaticObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `static public java.time.Instant parse(java.lang.CharSequence text)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Obtains an instance of {@code Instant} from a text string such as
  /// {@code 2007-12-03T10:15:30.00Z}.
  ///
  /// The string must represent a valid instant in UTC and is parsed using
  /// DateTimeFormatter\#ISO_INSTANT.
  ///@param text the text to parse, not null
  ///@return the parsed instant, not null
  ///@throws DateTimeParseException if the text cannot be parsed
  static Instant? parse(
    jni$_.JObject? text,
  ) {
    final _$text = text?.reference ?? jni$_.jNullReference;
    return _parse(_class.reference.pointer, _id_parse as jni$_.JMethodIDPtr,
            _$text.pointer)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_isSupported = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalField;)Z',
  );

  static final _isSupported = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean isSupported(java.time.temporal.TemporalField field)`
  ///
  /// Checks if the specified field is supported.
  ///
  /// This checks if this instant can be queried for the specified field.
  /// If false, then calling the \#range(TemporalField) range,
  /// \#get(TemporalField) get and \#with(TemporalField, long)
  /// methods will throw an exception.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The supported fields are:
  /// <ul>
  /// <li>{@code NANO_OF_SECOND}
  /// <li>{@code MICRO_OF_SECOND}
  /// <li>{@code MILLI_OF_SECOND}
  /// <li>{@code INSTANT_SECONDS}
  /// </ul>
  /// All other {@code ChronoField} instances will return false.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.isSupportedBy(TemporalAccessor)}
  /// passing {@code this} as the argument.
  /// Whether the field is supported is determined by the field.
  ///@param field the field to check, null returns false
  ///@return true if the field is supported on this instant, false if not
  bool isSupported(
    jni$_.JObject? field,
  ) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _isSupported(reference.pointer,
            _id_isSupported as jni$_.JMethodIDPtr, _$field.pointer)
        .boolean;
  }

  static final _id_isSupported$1 = _class.instanceMethodId(
    r'isSupported',
    r'(Ljava/time/temporal/TemporalUnit;)Z',
  );

  static final _isSupported$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean isSupported(java.time.temporal.TemporalUnit unit)`
  ///
  /// Checks if the specified unit is supported.
  ///
  /// This checks if the specified unit can be added to, or subtracted from, this date-time.
  /// If false, then calling the \#plus(long, TemporalUnit) and
  /// \#minus(long, TemporalUnit) minus methods will throw an exception.
  ///
  /// If the unit is a ChronoUnit then the query is implemented here.
  /// The supported units are:
  /// <ul>
  /// <li>{@code NANOS}
  /// <li>{@code MICROS}
  /// <li>{@code MILLIS}
  /// <li>{@code SECONDS}
  /// <li>{@code MINUTES}
  /// <li>{@code HOURS}
  /// <li>{@code HALF_DAYS}
  /// <li>{@code DAYS}
  /// </ul>
  /// All other {@code ChronoUnit} instances will return false.
  ///
  /// If the unit is not a {@code ChronoUnit}, then the result of this method
  /// is obtained by invoking {@code TemporalUnit.isSupportedBy(Temporal)}
  /// passing {@code this} as the argument.
  /// Whether the unit is supported is determined by the unit.
  ///@param unit the unit to check, null returns false
  ///@return true if the unit can be added/subtracted, false if not
  bool isSupported$1(
    jni$_.JObject? unit,
  ) {
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _isSupported$1(reference.pointer,
            _id_isSupported$1 as jni$_.JMethodIDPtr, _$unit.pointer)
        .boolean;
  }

  static final _id_range = _class.instanceMethodId(
    r'range',
    r'(Ljava/time/temporal/TemporalField;)Ljava/time/temporal/ValueRange;',
  );

  static final _range = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.temporal.ValueRange range(java.time.temporal.TemporalField field)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the range of valid values for the specified field.
  ///
  /// The range object expresses the minimum and maximum valid values for a field.
  /// This instant is used to enhance the accuracy of the returned range.
  /// If it is not possible to return the range, because the field is not supported
  /// or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The \#isSupported(TemporalField) supported fields will return
  /// appropriate range instances.
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.rangeRefinedBy(TemporalAccessor)}
  /// passing {@code this} as the argument.
  /// Whether the range can be obtained is determined by the field.
  ///@param field the field to query the range for, not null
  ///@return the range of valid values for the field, not null
  ///@throws DateTimeException if the range for the field cannot be obtained
  ///@throws UnsupportedTemporalTypeException if the field is not supported
  jni$_.JObject? range(
    jni$_.JObject? field,
  ) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _range(
            reference.pointer, _id_range as jni$_.JMethodIDPtr, _$field.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_get = _class.instanceMethodId(
    r'get',
    r'(Ljava/time/temporal/TemporalField;)I',
  );

  static final _get = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int get(java.time.temporal.TemporalField field)`
  ///
  /// Gets the value of the specified field from this instant as an {@code int}.
  ///
  /// This queries this instant for the value of the specified field.
  /// The returned value will always be within the valid range of values for the field.
  /// If it is not possible to return the value, because the field is not supported
  /// or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The \#isSupported(TemporalField) supported fields will return valid
  /// values based on this date-time, except {@code INSTANT_SECONDS} which is too
  /// large to fit in an {@code int} and throws a {@code DateTimeException}.
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
  /// passing {@code this} as the argument. Whether the value can be obtained,
  /// and what the value represents, is determined by the field.
  ///@param field the field to get, not null
  ///@return the value for the field
  ///@throws DateTimeException if a value for the field cannot be obtained or
  ///         the value is outside the range of valid values for the field
  ///@throws UnsupportedTemporalTypeException if the field is not supported or
  ///         the range of values exceeds an {@code int}
  ///@throws ArithmeticException if numeric overflow occurs
  int get(
    jni$_.JObject? field,
  ) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _get(
            reference.pointer, _id_get as jni$_.JMethodIDPtr, _$field.pointer)
        .integer;
  }

  static final _id_getLong = _class.instanceMethodId(
    r'getLong',
    r'(Ljava/time/temporal/TemporalField;)J',
  );

  static final _getLong = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public long getLong(java.time.temporal.TemporalField field)`
  ///
  /// Gets the value of the specified field from this instant as a {@code long}.
  ///
  /// This queries this instant for the value of the specified field.
  /// If it is not possible to return the value, because the field is not supported
  /// or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the query is implemented here.
  /// The \#isSupported(TemporalField) supported fields will return valid
  /// values based on this date-time.
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.getFrom(TemporalAccessor)}
  /// passing {@code this} as the argument. Whether the value can be obtained,
  /// and what the value represents, is determined by the field.
  ///@param field the field to get, not null
  ///@return the value for the field
  ///@throws DateTimeException if a value for the field cannot be obtained
  ///@throws UnsupportedTemporalTypeException if the field is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  int getLong(
    jni$_.JObject? field,
  ) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _getLong(reference.pointer, _id_getLong as jni$_.JMethodIDPtr,
            _$field.pointer)
        .long;
  }

  static final _id_getEpochSecond = _class.instanceMethodId(
    r'getEpochSecond',
    r'()J',
  );

  static final _getEpochSecond = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long getEpochSecond()`
  ///
  /// Gets the number of seconds from the Java epoch of 1970-01-01T00:00:00Z.
  ///
  /// The epoch second count is a simple incrementing count of seconds where
  /// second 0 is 1970-01-01T00:00:00Z.
  /// The nanosecond part is returned by \#getNano.
  ///@return the seconds from the epoch of 1970-01-01T00:00:00Z
  int getEpochSecond() {
    return _getEpochSecond(
            reference.pointer, _id_getEpochSecond as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_getNano = _class.instanceMethodId(
    r'getNano',
    r'()I',
  );

  static final _getNano = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int getNano()`
  ///
  /// Gets the number of nanoseconds, later along the time-line, from the start
  /// of the second.
  ///
  /// The nanosecond-of-second value measures the total number of nanoseconds from
  /// the second returned by \#getEpochSecond.
  ///@return the nanoseconds within the second, always positive, never exceeds 999,999,999
  int getNano() {
    return _getNano(reference.pointer, _id_getNano as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_with$ = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalAdjuster;)Ljava/time/Instant;',
  );

  static final _with$ = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.Instant with(java.time.temporal.TemporalAdjuster adjuster)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns an adjusted copy of this instant.
  ///
  /// This returns an {@code Instant}, based on this one, with the instant adjusted.
  /// The adjustment takes place using the specified adjuster strategy object.
  /// Read the documentation of the adjuster to understand what adjustment will be made.
  ///
  /// The result of this method is obtained by invoking the
  /// TemporalAdjuster\#adjustInto(Temporal) method on the
  /// specified adjuster passing {@code this} as the argument.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param adjuster the adjuster to use, not null
  ///@return an {@code Instant} based on {@code this} with the adjustment made, not null
  ///@throws DateTimeException if the adjustment cannot be made
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? with$(
    jni$_.JObject? adjuster,
  ) {
    final _$adjuster = adjuster?.reference ?? jni$_.jNullReference;
    return _with$(reference.pointer, _id_with$ as jni$_.JMethodIDPtr,
            _$adjuster.pointer)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_with$1 = _class.instanceMethodId(
    r'with',
    r'(Ljava/time/temporal/TemporalField;J)Ljava/time/Instant;',
  );

  static final _with$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int64)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>, int)>();

  /// from: `public java.time.Instant with(java.time.temporal.TemporalField field, long newValue)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified field set to a new value.
  ///
  /// This returns an {@code Instant}, based on this one, with the value
  /// for the specified field changed.
  /// If it is not possible to set the value, because the field is not supported or for
  /// some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoField then the adjustment is implemented here.
  /// The supported fields behave as follows:
  /// <ul>
  /// <li>{@code NANO_OF_SECOND} -
  ///  Returns an {@code Instant} with the specified nano-of-second.
  ///  The epoch-second will be unchanged.
  /// <li>{@code MICRO_OF_SECOND} -
  ///  Returns an {@code Instant} with the nano-of-second replaced by the specified
  ///  micro-of-second multiplied by 1,000. The epoch-second will be unchanged.
  /// <li>{@code MILLI_OF_SECOND} -
  ///  Returns an {@code Instant} with the nano-of-second replaced by the specified
  ///  milli-of-second multiplied by 1,000,000. The epoch-second will be unchanged.
  /// <li>{@code INSTANT_SECONDS} -
  ///  Returns an {@code Instant} with the specified epoch-second.
  ///  The nano-of-second will be unchanged.
  /// </ul>
  ///
  /// In all cases, if the new value is outside the valid range of values for the field
  /// then a {@code DateTimeException} will be thrown.
  ///
  /// All other {@code ChronoField} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoField}, then the result of this method
  /// is obtained by invoking {@code TemporalField.adjustInto(Temporal, long)}
  /// passing {@code this} as the argument. In this case, the field determines
  /// whether and how to adjust the instant.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param field the field to set in the result, not null
  ///@param newValue the new value of the field in the result
  ///@return an {@code Instant} based on {@code this} with the specified field set, not null
  ///@throws DateTimeException if the field cannot be set
  ///@throws UnsupportedTemporalTypeException if the field is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? with$1(
    jni$_.JObject? field,
    int newValue,
  ) {
    final _$field = field?.reference ?? jni$_.jNullReference;
    return _with$1(reference.pointer, _id_with$1 as jni$_.JMethodIDPtr,
            _$field.pointer, newValue)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_truncatedTo = _class.instanceMethodId(
    r'truncatedTo',
    r'(Ljava/time/temporal/TemporalUnit;)Ljava/time/Instant;',
  );

  static final _truncatedTo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.Instant truncatedTo(java.time.temporal.TemporalUnit unit)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this {@code Instant} truncated to the specified unit.
  ///
  /// Truncating the instant returns a copy of the original with fields
  /// smaller than the specified unit set to zero.
  /// The fields are calculated on the basis of using a UTC offset as seen
  /// in {@code toString}.
  /// For example, truncating with the ChronoUnit\#MINUTES MINUTES unit will
  /// round down to the nearest minute, setting the seconds and nanoseconds to zero.
  ///
  /// The unit must have a {@linkplain TemporalUnit\#getDuration() duration}
  /// that divides into the length of a standard day without remainder.
  /// This includes all supplied time units on ChronoUnit and
  /// ChronoUnit\#DAYS DAYS. Other units throw an exception.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param unit the unit to truncate to, not null
  ///@return an {@code Instant} based on this instant with the time truncated, not null
  ///@throws DateTimeException if the unit is invalid for truncation
  ///@throws UnsupportedTemporalTypeException if the unit is not supported
  Instant? truncatedTo(
    jni$_.JObject? unit,
  ) {
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _truncatedTo(reference.pointer,
            _id_truncatedTo as jni$_.JMethodIDPtr, _$unit.pointer)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plus = _class.instanceMethodId(
    r'plus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Instant;',
  );

  static final _plus = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.Instant plus(java.time.temporal.TemporalAmount amountToAdd)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified amount added.
  ///
  /// This returns an {@code Instant}, based on this one, with the specified amount added.
  /// The amount is typically Duration but may be any other type implementing
  /// the TemporalAmount interface.
  ///
  /// The calculation is delegated to the amount object by calling
  /// TemporalAmount\#addTo(Temporal). The amount implementation is free
  /// to implement the addition in any way it wishes, however it typically
  /// calls back to \#plus(long, TemporalUnit). Consult the documentation
  /// of the amount implementation to determine if it can be successfully added.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param amountToAdd the amount to add, not null
  ///@return an {@code Instant} based on this instant with the addition made, not null
  ///@throws DateTimeException if the addition cannot be made
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? plus(
    jni$_.JObject? amountToAdd,
  ) {
    final _$amountToAdd = amountToAdd?.reference ?? jni$_.jNullReference;
    return _plus(reference.pointer, _id_plus as jni$_.JMethodIDPtr,
            _$amountToAdd.pointer)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plus$1 = _class.instanceMethodId(
    r'plus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Instant;',
  );

  static final _plus$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.Instant plus(long amountToAdd, java.time.temporal.TemporalUnit unit)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified amount added.
  ///
  /// This returns an {@code Instant}, based on this one, with the amount
  /// in terms of the unit added. If it is not possible to add the amount, because the
  /// unit is not supported or for some other reason, an exception is thrown.
  ///
  /// If the field is a ChronoUnit then the addition is implemented here.
  /// The supported fields behave as follows:
  /// <ul>
  /// <li>{@code NANOS} -
  ///  Returns an {@code Instant} with the specified number of nanoseconds added.
  ///  This is equivalent to \#plusNanos(long).
  /// <li>{@code MICROS} -
  ///  Returns an {@code Instant} with the specified number of microseconds added.
  ///  This is equivalent to \#plusNanos(long) with the amount
  ///  multiplied by 1,000.
  /// <li>{@code MILLIS} -
  ///  Returns an {@code Instant} with the specified number of milliseconds added.
  ///  This is equivalent to \#plusNanos(long) with the amount
  ///  multiplied by 1,000,000.
  /// <li>{@code SECONDS} -
  ///  Returns an {@code Instant} with the specified number of seconds added.
  ///  This is equivalent to \#plusSeconds(long).
  /// <li>{@code MINUTES} -
  ///  Returns an {@code Instant} with the specified number of minutes added.
  ///  This is equivalent to \#plusSeconds(long) with the amount
  ///  multiplied by 60.
  /// <li>{@code HOURS} -
  ///  Returns an {@code Instant} with the specified number of hours added.
  ///  This is equivalent to \#plusSeconds(long) with the amount
  ///  multiplied by 3,600.
  /// <li>{@code HALF_DAYS} -
  ///  Returns an {@code Instant} with the specified number of half-days added.
  ///  This is equivalent to \#plusSeconds(long) with the amount
  ///  multiplied by 43,200 (12 hours).
  /// <li>{@code DAYS} -
  ///  Returns an {@code Instant} with the specified number of days added.
  ///  This is equivalent to \#plusSeconds(long) with the amount
  ///  multiplied by 86,400 (24 hours).
  /// </ul>
  ///
  /// All other {@code ChronoUnit} instances will throw an {@code UnsupportedTemporalTypeException}.
  ///
  /// If the field is not a {@code ChronoUnit}, then the result of this method
  /// is obtained by invoking {@code TemporalUnit.addTo(Temporal, long)}
  /// passing {@code this} as the argument. In this case, the unit determines
  /// whether and how to perform the addition.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param amountToAdd the amount of the unit to add to the result, may be negative
  ///@param unit the unit of the amount to add, not null
  ///@return an {@code Instant} based on this instant with the specified amount added, not null
  ///@throws DateTimeException if the addition cannot be made
  ///@throws UnsupportedTemporalTypeException if the unit is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? plus$1(
    int amountToAdd,
    jni$_.JObject? unit,
  ) {
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _plus$1(reference.pointer, _id_plus$1 as jni$_.JMethodIDPtr,
            amountToAdd, _$unit.pointer)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plusSeconds = _class.instanceMethodId(
    r'plusSeconds',
    r'(J)Ljava/time/Instant;',
  );

  static final _plusSeconds = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.Instant plusSeconds(long secondsToAdd)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified duration in seconds added.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param secondsToAdd the seconds to add, positive or negative
  ///@return an {@code Instant} based on this instant with the specified seconds added, not null
  ///@throws DateTimeException if the result exceeds the maximum or minimum instant
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? plusSeconds(
    int secondsToAdd,
  ) {
    return _plusSeconds(reference.pointer,
            _id_plusSeconds as jni$_.JMethodIDPtr, secondsToAdd)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plusMillis = _class.instanceMethodId(
    r'plusMillis',
    r'(J)Ljava/time/Instant;',
  );

  static final _plusMillis = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.Instant plusMillis(long millisToAdd)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified duration in milliseconds added.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param millisToAdd the milliseconds to add, positive or negative
  ///@return an {@code Instant} based on this instant with the specified milliseconds added, not null
  ///@throws DateTimeException if the result exceeds the maximum or minimum instant
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? plusMillis(
    int millisToAdd,
  ) {
    return _plusMillis(reference.pointer, _id_plusMillis as jni$_.JMethodIDPtr,
            millisToAdd)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_plusNanos = _class.instanceMethodId(
    r'plusNanos',
    r'(J)Ljava/time/Instant;',
  );

  static final _plusNanos = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.Instant plusNanos(long nanosToAdd)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified duration in nanoseconds added.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param nanosToAdd the nanoseconds to add, positive or negative
  ///@return an {@code Instant} based on this instant with the specified nanoseconds added, not null
  ///@throws DateTimeException if the result exceeds the maximum or minimum instant
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? plusNanos(
    int nanosToAdd,
  ) {
    return _plusNanos(
            reference.pointer, _id_plusNanos as jni$_.JMethodIDPtr, nanosToAdd)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minus = _class.instanceMethodId(
    r'minus',
    r'(Ljava/time/temporal/TemporalAmount;)Ljava/time/Instant;',
  );

  static final _minus = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.Instant minus(java.time.temporal.TemporalAmount amountToSubtract)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified amount subtracted.
  ///
  /// This returns an {@code Instant}, based on this one, with the specified amount subtracted.
  /// The amount is typically Duration but may be any other type implementing
  /// the TemporalAmount interface.
  ///
  /// The calculation is delegated to the amount object by calling
  /// TemporalAmount\#subtractFrom(Temporal). The amount implementation is free
  /// to implement the subtraction in any way it wishes, however it typically
  /// calls back to \#minus(long, TemporalUnit). Consult the documentation
  /// of the amount implementation to determine if it can be successfully subtracted.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param amountToSubtract the amount to subtract, not null
  ///@return an {@code Instant} based on this instant with the subtraction made, not null
  ///@throws DateTimeException if the subtraction cannot be made
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? minus(
    jni$_.JObject? amountToSubtract,
  ) {
    final _$amountToSubtract =
        amountToSubtract?.reference ?? jni$_.jNullReference;
    return _minus(reference.pointer, _id_minus as jni$_.JMethodIDPtr,
            _$amountToSubtract.pointer)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minus$1 = _class.instanceMethodId(
    r'minus',
    r'(JLjava/time/temporal/TemporalUnit;)Ljava/time/Instant;',
  );

  static final _minus$1 = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_
                          .VarArgs<(jni$_.Int64, jni$_.Pointer<jni$_.Void>)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.Instant minus(long amountToSubtract, java.time.temporal.TemporalUnit unit)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified amount subtracted.
  ///
  /// This returns an {@code Instant}, based on this one, with the amount
  /// in terms of the unit subtracted. If it is not possible to subtract the amount,
  /// because the unit is not supported or for some other reason, an exception is thrown.
  ///
  /// This method is equivalent to \#plus(long, TemporalUnit) with the amount negated.
  /// See that method for a full description of how addition, and thus subtraction, works.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param amountToSubtract the amount of the unit to subtract from the result, may be negative
  ///@param unit the unit of the amount to subtract, not null
  ///@return an {@code Instant} based on this instant with the specified amount subtracted, not null
  ///@throws DateTimeException if the subtraction cannot be made
  ///@throws UnsupportedTemporalTypeException if the unit is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? minus$1(
    int amountToSubtract,
    jni$_.JObject? unit,
  ) {
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _minus$1(reference.pointer, _id_minus$1 as jni$_.JMethodIDPtr,
            amountToSubtract, _$unit.pointer)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minusSeconds = _class.instanceMethodId(
    r'minusSeconds',
    r'(J)Ljava/time/Instant;',
  );

  static final _minusSeconds = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.Instant minusSeconds(long secondsToSubtract)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified duration in seconds subtracted.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param secondsToSubtract the seconds to subtract, positive or negative
  ///@return an {@code Instant} based on this instant with the specified seconds subtracted, not null
  ///@throws DateTimeException if the result exceeds the maximum or minimum instant
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? minusSeconds(
    int secondsToSubtract,
  ) {
    return _minusSeconds(reference.pointer,
            _id_minusSeconds as jni$_.JMethodIDPtr, secondsToSubtract)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minusMillis = _class.instanceMethodId(
    r'minusMillis',
    r'(J)Ljava/time/Instant;',
  );

  static final _minusMillis = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.Instant minusMillis(long millisToSubtract)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified duration in milliseconds subtracted.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param millisToSubtract the milliseconds to subtract, positive or negative
  ///@return an {@code Instant} based on this instant with the specified milliseconds subtracted, not null
  ///@throws DateTimeException if the result exceeds the maximum or minimum instant
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? minusMillis(
    int millisToSubtract,
  ) {
    return _minusMillis(reference.pointer,
            _id_minusMillis as jni$_.JMethodIDPtr, millisToSubtract)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_minusNanos = _class.instanceMethodId(
    r'minusNanos',
    r'(J)Ljava/time/Instant;',
  );

  static final _minusNanos = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<(jni$_.Int64,)>)>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public java.time.Instant minusNanos(long nanosToSubtract)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a copy of this instant with the specified duration in nanoseconds subtracted.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param nanosToSubtract the nanoseconds to subtract, positive or negative
  ///@return an {@code Instant} based on this instant with the specified nanoseconds subtracted, not null
  ///@throws DateTimeException if the result exceeds the maximum or minimum instant
  ///@throws ArithmeticException if numeric overflow occurs
  Instant? minusNanos(
    int nanosToSubtract,
  ) {
    return _minusNanos(reference.pointer, _id_minusNanos as jni$_.JMethodIDPtr,
            nanosToSubtract)
        .object<Instant?>(const $Instant$NullableType());
  }

  static final _id_query = _class.instanceMethodId(
    r'query',
    r'(Ljava/time/temporal/TemporalQuery;)Ljava/lang/Object;',
  );

  static final _query = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public R query(java.time.temporal.TemporalQuery<R> query)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Queries this instant using the specified query.
  ///
  /// This queries this instant using the specified query strategy object.
  /// The {@code TemporalQuery} object defines the logic to be used to
  /// obtain the result. Read the documentation of the query to understand
  /// what the result of this method will be.
  ///
  /// The result of this method is obtained by invoking the
  /// TemporalQuery\#queryFrom(TemporalAccessor) method on the
  /// specified query passing {@code this} as the argument.
  ///@param <R> the type of the result
  ///@param query the query to invoke, not null
  ///@return the query result, null may be returned (defined by the query)
  ///@throws DateTimeException if unable to query (defined by the query)
  ///@throws ArithmeticException if numeric overflow occurs (defined by the query)
  $R? query<$R extends jni$_.JObject?>(
    jni$_.JObject? query, {
    required jni$_.JObjType<$R> R,
  }) {
    final _$query = query?.reference ?? jni$_.jNullReference;
    return _query(
            reference.pointer, _id_query as jni$_.JMethodIDPtr, _$query.pointer)
        .object<$R?>(R.nullableType);
  }

  static final _id_adjustInto = _class.instanceMethodId(
    r'adjustInto',
    r'(Ljava/time/temporal/Temporal;)Ljava/time/temporal/Temporal;',
  );

  static final _adjustInto = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.temporal.Temporal adjustInto(java.time.temporal.Temporal temporal)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Adjusts the specified temporal object to have this instant.
  ///
  /// This returns a temporal object of the same observable type as the input
  /// with the instant changed to be the same as this.
  ///
  /// The adjustment is equivalent to using Temporal\#with(TemporalField, long)
  /// twice, passing ChronoField\#INSTANT_SECONDS and
  /// ChronoField\#NANO_OF_SECOND as the fields.
  ///
  /// In most cases, it is clearer to reverse the calling pattern by using
  /// Temporal\#with(TemporalAdjuster):
  /// <pre>
  ///   // these two lines are equivalent, but the second approach is recommended
  ///   temporal = thisInstant.adjustInto(temporal);
  ///   temporal = temporal.with(thisInstant);
  /// </pre>
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param temporal the target object to be adjusted, not null
  ///@return the adjusted object, not null
  ///@throws DateTimeException if unable to make the adjustment
  ///@throws ArithmeticException if numeric overflow occurs
  jni$_.JObject? adjustInto(
    jni$_.JObject? temporal,
  ) {
    final _$temporal = temporal?.reference ?? jni$_.jNullReference;
    return _adjustInto(reference.pointer, _id_adjustInto as jni$_.JMethodIDPtr,
            _$temporal.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_until = _class.instanceMethodId(
    r'until',
    r'(Ljava/time/temporal/Temporal;Ljava/time/temporal/TemporalUnit;)J',
  );

  static final _until = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                  jni$_.Pointer<jni$_.Void>,
                  jni$_.JMethodIDPtr,
                  jni$_.VarArgs<
                      (
                        jni$_.Pointer<jni$_.Void>,
                        jni$_.Pointer<jni$_.Void>
                      )>)>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>)>();

  /// from: `public long until(java.time.temporal.Temporal endExclusive, java.time.temporal.TemporalUnit unit)`
  ///
  /// Calculates the amount of time until another instant in terms of the specified unit.
  ///
  /// This calculates the amount of time between two {@code Instant}
  /// objects in terms of a single {@code TemporalUnit}.
  /// The start and end points are {@code this} and the specified instant.
  /// The result will be negative if the end is before the start.
  /// The calculation returns a whole number, representing the number of
  /// complete units between the two instants.
  /// The {@code Temporal} passed to this method is converted to a
  /// {@code Instant} using \#from(TemporalAccessor).
  /// For example, the amount in seconds between two dates can be calculated
  /// using {@code startInstant.until(endInstant, SECONDS)}.
  ///
  /// There are two equivalent ways of using this method.
  /// The first is to invoke this method.
  /// The second is to use TemporalUnit\#between(Temporal, Temporal):
  /// <pre>
  ///   // these two lines are equivalent
  ///   amount = start.until(end, SECONDS);
  ///   amount = SECONDS.between(start, end);
  /// </pre>
  /// The choice should be made based on which makes the code more readable.
  ///
  /// The calculation is implemented in this method for ChronoUnit.
  /// The units {@code NANOS}, {@code MICROS}, {@code MILLIS}, {@code SECONDS},
  /// {@code MINUTES}, {@code HOURS}, {@code HALF_DAYS} and {@code DAYS}
  /// are supported. Other {@code ChronoUnit} values will throw an exception.
  ///
  /// If the unit is not a {@code ChronoUnit}, then the result of this method
  /// is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}
  /// passing {@code this} as the first argument and the converted input temporal
  /// as the second argument.
  ///
  /// This instance is immutable and unaffected by this method call.
  ///@param endExclusive the end date, exclusive, which is converted to an {@code Instant}, not null
  ///@param unit the unit to measure the amount in, not null
  ///@return the amount of time between this instant and the end instant
  ///@throws DateTimeException if the amount cannot be calculated, or the end
  ///  temporal cannot be converted to an {@code Instant}
  ///@throws UnsupportedTemporalTypeException if the unit is not supported
  ///@throws ArithmeticException if numeric overflow occurs
  int until(
    jni$_.JObject? endExclusive,
    jni$_.JObject? unit,
  ) {
    final _$endExclusive = endExclusive?.reference ?? jni$_.jNullReference;
    final _$unit = unit?.reference ?? jni$_.jNullReference;
    return _until(reference.pointer, _id_until as jni$_.JMethodIDPtr,
            _$endExclusive.pointer, _$unit.pointer)
        .long;
  }

  static final _id_atOffset = _class.instanceMethodId(
    r'atOffset',
    r'(Ljava/time/ZoneOffset;)Ljava/time/OffsetDateTime;',
  );

  static final _atOffset = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.OffsetDateTime atOffset(java.time.ZoneOffset offset)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Combines this instant with an offset to create an {@code OffsetDateTime}.
  ///
  /// This returns an {@code OffsetDateTime} formed from this instant at the
  /// specified offset from UTC/Greenwich. An exception will be thrown if the
  /// instant is too large to fit into an offset date-time.
  ///
  /// This method is equivalent to
  /// OffsetDateTime\#ofInstant(Instant, ZoneId) OffsetDateTime.ofInstant(this, offset).
  ///@param offset the offset to combine with, not null
  ///@return the offset date-time formed from this instant and the specified offset, not null
  ///@throws DateTimeException if the result exceeds the supported range
  jni$_.JObject? atOffset(
    ZoneOffset? offset,
  ) {
    final _$offset = offset?.reference ?? jni$_.jNullReference;
    return _atOffset(reference.pointer, _id_atOffset as jni$_.JMethodIDPtr,
            _$offset.pointer)
        .object<jni$_.JObject?>(const jni$_.JObjectNullableType());
  }

  static final _id_atZone = _class.instanceMethodId(
    r'atZone',
    r'(Ljava/time/ZoneId;)Ljava/time/ZonedDateTime;',
  );

  static final _atZone = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public java.time.ZonedDateTime atZone(java.time.ZoneId zone)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Combines this instant with a time-zone to create a {@code ZonedDateTime}.
  ///
  /// This returns an {@code ZonedDateTime} formed from this instant at the
  /// specified time-zone. An exception will be thrown if the instant is too
  /// large to fit into a zoned date-time.
  ///
  /// This method is equivalent to
  /// ZonedDateTime\#ofInstant(Instant, ZoneId) ZonedDateTime.ofInstant(this, zone).
  ///@param zone the zone to combine with, not null
  ///@return the zoned date-time formed from this instant and the specified zone, not null
  ///@throws DateTimeException if the result exceeds the supported range
  ZonedDateTime? atZone(
    ZoneId? zone,
  ) {
    final _$zone = zone?.reference ?? jni$_.jNullReference;
    return _atZone(
            reference.pointer, _id_atZone as jni$_.JMethodIDPtr, _$zone.pointer)
        .object<ZonedDateTime?>(const $ZonedDateTime$NullableType());
  }

  static final _id_toEpochMilli = _class.instanceMethodId(
    r'toEpochMilli',
    r'()J',
  );

  static final _toEpochMilli = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallLongMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public long toEpochMilli()`
  ///
  /// Converts this instant to the number of milliseconds from the epoch
  /// of 1970-01-01T00:00:00Z.
  ///
  /// If this instant represents a point on the time-line too far in the future
  /// or past to fit in a {@code long} milliseconds, then an exception is thrown.
  ///
  /// If this instant has greater than millisecond precision, then the conversion
  /// will drop any excess precision information as though the amount in nanoseconds
  /// was subject to integer division by one million.
  ///@return the number of milliseconds since the epoch of 1970-01-01T00:00:00Z
  ///@throws ArithmeticException if numeric overflow occurs
  int toEpochMilli() {
    return _toEpochMilli(
            reference.pointer, _id_toEpochMilli as jni$_.JMethodIDPtr)
        .long;
  }

  static final _id_compareTo = _class.instanceMethodId(
    r'compareTo',
    r'(Ljava/time/Instant;)I',
  );

  static final _compareTo = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public int compareTo(java.time.Instant otherInstant)`
  ///
  /// Compares this instant to the specified instant.
  ///
  /// The comparison is based on the time-line position of the instants.
  /// It is "consistent with equals", as defined by Comparable.
  ///@param otherInstant the other instant to compare to, not null
  ///@return the comparator value, negative if less, positive if greater
  ///@throws NullPointerException if otherInstant is null
  int compareTo(
    Instant? otherInstant,
  ) {
    final _$otherInstant = otherInstant?.reference ?? jni$_.jNullReference;
    return _compareTo(reference.pointer, _id_compareTo as jni$_.JMethodIDPtr,
            _$otherInstant.pointer)
        .integer;
  }

  static final _id_isAfter = _class.instanceMethodId(
    r'isAfter',
    r'(Ljava/time/Instant;)Z',
  );

  static final _isAfter = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean isAfter(java.time.Instant otherInstant)`
  ///
  /// Checks if this instant is after the specified instant.
  ///
  /// The comparison is based on the time-line position of the instants.
  ///@param otherInstant the other instant to compare to, not null
  ///@return true if this instant is after the specified instant
  ///@throws NullPointerException if otherInstant is null
  bool isAfter(
    Instant? otherInstant,
  ) {
    final _$otherInstant = otherInstant?.reference ?? jni$_.jNullReference;
    return _isAfter(reference.pointer, _id_isAfter as jni$_.JMethodIDPtr,
            _$otherInstant.pointer)
        .boolean;
  }

  static final _id_isBefore = _class.instanceMethodId(
    r'isBefore',
    r'(Ljava/time/Instant;)Z',
  );

  static final _isBefore = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean isBefore(java.time.Instant otherInstant)`
  ///
  /// Checks if this instant is before the specified instant.
  ///
  /// The comparison is based on the time-line position of the instants.
  ///@param otherInstant the other instant to compare to, not null
  ///@return true if this instant is before the specified instant
  ///@throws NullPointerException if otherInstant is null
  bool isBefore(
    Instant? otherInstant,
  ) {
    final _$otherInstant = otherInstant?.reference ?? jni$_.jNullReference;
    return _isBefore(reference.pointer, _id_isBefore as jni$_.JMethodIDPtr,
            _$otherInstant.pointer)
        .boolean;
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals = jni$_.ProtectedJniExtensions.lookup<
              jni$_.NativeFunction<
                  jni$_.JniResult Function(
                      jni$_.Pointer<jni$_.Void>,
                      jni$_.JMethodIDPtr,
                      jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>)>>(
          'globalEnv_CallBooleanMethod')
      .asFunction<
          jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)>();

  /// from: `public boolean equals(java.lang.Object otherInstant)`
  ///
  /// Checks if this instant is equal to the specified instant.
  ///
  /// The comparison is based on the time-line position of the instants.
  ///@param otherInstant the other instant, null returns false
  ///@return true if the other instant is equal to this one
  bool equals(
    jni$_.JObject? otherInstant,
  ) {
    final _$otherInstant = otherInstant?.reference ?? jni$_.jNullReference;
    return _equals(reference.pointer, _id_equals as jni$_.JMethodIDPtr,
            _$otherInstant.pointer)
        .boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallIntMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public int hashCode()`
  ///
  /// Returns a hash code for this instant.
  ///@return a suitable hash code
  int hashCode$1() {
    return _hashCode$1(reference.pointer, _id_hashCode$1 as jni$_.JMethodIDPtr)
        .integer;
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 = jni$_.ProtectedJniExtensions.lookup<
          jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )>>('globalEnv_CallObjectMethod')
      .asFunction<
          jni$_.JniResult Function(
            jni$_.Pointer<jni$_.Void>,
            jni$_.JMethodIDPtr,
          )>();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// A string representation of this instant using ISO-8601 representation.
  ///
  /// The format used is the same as DateTimeFormatter\#ISO_INSTANT.
  ///@return an ISO-8601 representation of this instant, not null
  jni$_.JString? toString$1() {
    return _toString$1(reference.pointer, _id_toString$1 as jni$_.JMethodIDPtr)
        .object<jni$_.JString?>(const jni$_.JStringNullableType());
  }
}

final class $Instant$NullableType extends jni$_.JObjType<Instant?> {
  @jni$_.internal
  const $Instant$NullableType();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Instant;';

  @jni$_.internal
  @core$_.override
  Instant? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Instant.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Instant?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Instant$NullableType).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Instant$NullableType) &&
        other is $Instant$NullableType;
  }
}

final class $Instant$Type extends jni$_.JObjType<Instant> {
  @jni$_.internal
  const $Instant$Type();

  @jni$_.internal
  @core$_.override
  String get signature => r'Ljava/time/Instant;';

  @jni$_.internal
  @core$_.override
  Instant fromReference(jni$_.JReference reference) => Instant.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JObjType get superType => const jni$_.JObjectNullableType();

  @jni$_.internal
  @core$_.override
  jni$_.JObjType<Instant?> get nullableType => const $Instant$NullableType();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Instant$Type).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Instant$Type) && other is $Instant$Type;
  }
}
